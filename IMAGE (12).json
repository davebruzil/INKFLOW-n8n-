{
  "name": "IMAGE",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "whatsapp-webhook",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -2288,
        64
      ],
      "id": "0a7924be-c060-43c1-a325-cb3a9164b4d9",
      "name": "WhatsApp Webhook Receiver",
      "webhookId": "e0348897-9433-457d-8cd5-8c80663857a7"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "sessionId"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1072,
        224
      ],
      "id": "06b98bc2-406c-4686-8ef4-874364075589",
      "name": "Agent Memory"
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Enhanced detection for WhatsApp conversations\n// CRITICAL FIX: AI Agent doesn't pass through input fields, only AI output!\n// So we get WhatsApp data DIRECTLY from Code node to preserve sessionId\n\nconst currentItem = $input.first().json;\nconst aiResponse = currentItem.output || currentItem.response || currentItem.text || '';\n\n// CRITICAL FIX: Get WhatsApp data from Code node directly (AI Agent loses sessionId!)\nconst codeNodeData = $('Code').first().json;\n\nconsole.log('ğŸ¤– AI Response:', aiResponse);\nconsole.log('ğŸ“± Code Node Data - sessionId:', codeNodeData.sessionId);\nconsole.log('ğŸ“± Code Node Data - senderPhone:', codeNodeData.senderPhone);\n\nlet shouldTriggerSummary = false;\nlet extractedName = '';\nlet triggerReason = '';\nlet foundCompletions = [];\n\ntry {\n  // Get user input from Code node data\n  const userInput = codeNodeData.chatInput || '';\n  const senderPhone = codeNodeData.senderPhone || '';\n  const senderName = codeNodeData.senderName || '';\n\n  console.log('ğŸ‘¤ User Input:', userInput);\n  console.log('ğŸ“ Sender Phone:', senderPhone);\n  console.log('ğŸ“ Session ID:', codeNodeData.sessionId);\n  console.log('ğŸ‘¤ Sender Name:', senderName);\n\n  // Extract name from user input first\n  if (userInput) {\n    const userNamePatterns = [\n      /(?:×× ×™|×§×•×¨××™× ×œ×™|×”×©× ×©×œ×™|×©××™)\\s+([×-×ª]{2,15})/i,\n      /^([×-×ª]{2,10})$/,\n      /×”×™×™.*?×× ×™\\s+([×-×ª]{2,15})/i\n    ];\n\n    for (const pattern of userNamePatterns) {\n      const match = userInput.match(pattern);\n      if (match && match[1]) {\n        const candidate = match[1].trim();\n        const excludeWords = ['×¨×•×¦×”', '×¦×¨×™×š', '××¢×•× ×™×™×Ÿ', '×—×•×©×‘', '×˜×•×‘', '×™×¤×”'];\n        if (!excludeWords.includes(candidate)) {\n          extractedName = candidate;\n          console.log('âœ… Name from user input:', extractedName);\n          break;\n        }\n      }\n    }\n  }\n\n  // Extract name from AI response if not found in user input\n  if (!extractedName && aiResponse) {\n    const thankPattern = /×ª×•×“×”\\s+([×-×ª]{2,15})/i;\n    const thankMatch = aiResponse.match(thankPattern);\n    if (thankMatch && thankMatch[1]) {\n      extractedName = thankMatch[1];\n      console.log('âœ… Name from \"×ª×•×“×” [×©×]\" pattern:', extractedName);\n    }\n    \n    if (!extractedName) {\n      const greetingPattern = /(?:××•×©×œ×|× ×¢×™×|×¡×‘×‘×”),?\\s+([×-×ª]{2,15})/i;\n      const greetingMatch = aiResponse.match(greetingPattern);\n      if (greetingMatch && greetingMatch[1]) {\n        extractedName = greetingMatch[1];\n        console.log('âœ… Name from greeting pattern:', extractedName);\n      }\n    }\n  }\n\n  // Check for completion indicators\n  const completionPhrases = [\n    '×ª×•×“×”',\n    '××•×©×œ×', \n    '××¢×•×œ×”',\n    '× ×—×–×•×¨ ××œ×™×š',\n    '××¢×‘×™×¨ ×œ××§×¢×§×¢×ª',\n    '× ×§×‘×¢ ×œ×š',\n    '× ×™×¦×•×¨ ×§×©×¨',\n    '× ×ª××',\n    '××ª ×”×¤×¨×˜×™× ×©×œ×š',\n    '×‘×”×§×“×'\n  ];\n\n  foundCompletions = completionPhrases.filter(phrase => aiResponse.includes(phrase));\n  console.log('âœ… Completion phrases found:', foundCompletions);\n\n  // Decision logic\n  if (extractedName && foundCompletions.length > 0) {\n    shouldTriggerSummary = true;\n    triggerReason = `Name \"${extractedName}\" + ${foundCompletions.length} completion phrases: ${foundCompletions.join(', ')}`;\n  } else if (foundCompletions.length >= 2) {\n    shouldTriggerSummary = true;\n    triggerReason = `Strong completion indicators (${foundCompletions.length}): ${foundCompletions.join(', ')}`;\n  } else if (extractedName && aiResponse.includes('×ª×•×“×”')) {\n    shouldTriggerSummary = true;\n    triggerReason = `AI thanking user \"${extractedName}\"`;\n  } else {\n    triggerReason = `Insufficient indicators - Name: \"${extractedName}\", Completions: ${foundCompletions.length}`;\n  }\n\n  console.log('ğŸ“Š FINAL DECISION:');\n  console.log('  Name:', extractedName || 'None');\n  console.log('  Trigger:', shouldTriggerSummary);\n  console.log('  Reason:', triggerReason);\n\n} catch (error) {\n  console.error('âŒ Error:', error.message);\n  shouldTriggerSummary = false;\n  triggerReason = 'Error occurred: ' + error.message;\n  foundCompletions = [];\n}\n\nreturn [{\n  json: {\n    // Pass through ALL WhatsApp data from Code node (AI Agent doesn't pass it!)\n    ...codeNodeData,\n    // Add/override with AI response and detection results\n    output: aiResponse,\n    response: aiResponse,\n    text: aiResponse,\n    shouldTriggerSummary: shouldTriggerSummary,\n    extractedName: extractedName,\n    triggerReason: triggerReason,\n    // Explicitly preserve critical fields from Code node\n    senderPhone: codeNodeData.senderPhone,\n    senderName: codeNodeData.senderName,\n    sessionId: codeNodeData.sessionId,  // â† REAL sessionId preserved!\n    chatInput: codeNodeData.chatInput,\n    messageType: codeNodeData.messageType,\n    to: codeNodeData.to,  // For Send WhatsApp Reply\n    debug: {\n      foundCompletions: foundCompletions || [],\n      hasName: !!extractedName,\n      completionCount: (foundCompletions || []).length,\n      sessionIdSource: 'Code node (AI Agent bypassed)'\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        64
      ],
      "id": "7b2f8ee0-1c20-4d51-9e24-834d7ebf69e2",
      "name": "Process AI Response"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.wasenderapi.com/api/send-message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.output }}"
            },
            {
              "name": "to",
              "value": "={{ $('Code').item.json.to }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -528,
        224
      ],
      "id": "504010bb-fc3a-4b85-8665-b052fb1a8ebf",
      "name": "Send WhatsApp Reply"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "2020e6a3-53c5-4003-aac8-aa94343fc3b7",
              "leftValue": "={{ $json.shouldTriggerSummary }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "prevent-image-summary-trigger",
              "leftValue": "={{ $json.messageType }}",
              "rightValue": "image",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -688,
        48
      ],
      "id": "bcef2822-dad1-4600-abd9-5754ebcabba3",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Prepare WhatsApp Summary - Ensures phone number is always available\n\nconsole.log('=== PREPARING WHATSAPP SUMMARY WITH FULL HISTORY + IMAGES ===');\n\nlet conversationContext = '';\nlet whatsappData = null;\n\ntry {\n  const currentInput = $input.first().json;\n  \n  console.log('ğŸ” PREPARE SUMMARY - Input keys:', Object.keys(currentInput));\n  console.log('ğŸ” PREPARE SUMMARY - currentInput.sessionId:', currentInput.sessionId);\n  console.log('ğŸ” PREPARE SUMMARY - currentInput.senderPhone:', currentInput.senderPhone);\n  console.log('ğŸ” PREPARE SUMMARY - currentInput.senderName:', currentInput.senderName);\n  console.log('ğŸ” PREPARE SUMMARY - FULL INPUT:', JSON.stringify(currentInput, null, 2));\n  \n  // CRITICAL FIX: Extract phone from sessionId if not in senderPhone\n  // sessionId format: \"whatsapp_972501234567\"\n  let phoneNumber = currentInput.senderPhone || '';\n  \n  if (!phoneNumber && currentInput.sessionId) {\n    phoneNumber = currentInput.sessionId.replace('whatsapp_', '');\n    console.log(`ğŸ“ Extracted phone from sessionId: ${phoneNumber}`);\n  }\n  \n  // Get WhatsApp data - PRESERVE sessionId from input!\n  whatsappData = {\n    chatInput: currentInput.chatInput || '',\n    senderPhone: phoneNumber,\n    senderName: currentInput.senderName || currentInput.extractedName || '',\n    sessionId: currentInput.sessionId || ''  // DON'T use fallback here yet\n  };\n  \n  console.log('ğŸ“ Final phone number for summary:', whatsappData.senderPhone);\n  console.log('ğŸ“ Final sessionId for summary:', whatsappData.sessionId);\n  \n  // Use the FULL conversation history that was stored\n  const fullHistory = currentInput.fullConversationHistory || '';\n  const exchanges = currentInput.conversationExchanges || [];\n  \n  // Check if conversation includes images\n  const hasImages = exchanges.some(ex => ex.hasImage);\n  const imageUrls = exchanges.filter(ex => ex.imageUrl).map(ex => ex.imageUrl);\n  \n  if (fullHistory) {\n    console.log(`âœ… Using stored conversation history with ${exchanges.length} exchanges`);\n    console.log(`ğŸ“· Images in conversation: ${imageUrls.length}`);\n    \n    conversationContext = `×©×™×—×ª WhatsApp ×”××œ××”:\n××¡×¤×¨ ×˜×œ×¤×•×Ÿ: ${whatsappData.senderPhone}\n×©×: ${whatsappData.senderName || '×œ× ×¦×•×™×Ÿ'}\n\n×”×™×¡×˜×•×¨×™×™×ª ×”×©×™×—×” ×”××œ××” (${exchanges.length} ×”×—×œ×¤×•×ª):\n${fullHistory}`;\n    \n    if (hasImages) {\n      conversationContext += `\n\n×ª××•× ×•×ª ×©× ×©×œ×—×• (${imageUrls.length}):\n${imageUrls.map((url, i) => `${i+1}. ${url}`).join('\\n')}`;\n    }\n    \n    conversationContext += `\n\n×”×•×¨××•×ª ×œ×¡×™×›×•×: ×ª×—×œ×¥ ××”×©×™×—×” ×”××œ××”:\n1. ×©× ×”×œ×§×•×— (×‘×“×™×•×§ ×›×¤×™ ×©×”×•×–×›×¨ ×‘×©×™×—×”)\n2. ×¨×¢×™×•×Ÿ ×”×§×¢×§×•×¢ ×¢× ×›×œ ×”×¤×¨×˜×™× ×©×”×•×–×›×¨×•: ×’×•×“×œ, ××™×§×•×, ×¡×’× ×•×Ÿ, ×ª×™××•×¨ ××¤×•×¨×˜\n3. ×”×× × ×©×œ×—×• ×ª××•× ×•×ª ×•×”×§×©×¨ ×©×œ×”×Ÿ ×œ×¨×¢×™×•×Ÿ`;\n    \n  } else {\n    console.log('âš ï¸ No stored history, using current exchange only');\n    conversationContext = `×©×™×—×ª WhatsApp:\n××¡×¤×¨ ×˜×œ×¤×•×Ÿ: ${whatsappData.senderPhone}\n\n×”×•×“×¢×ª ×”×œ×§×•×—: ${currentInput.chatInput || ''}\n\n×ª×’×•×‘×ª ×”××¢×¨×›×ª: ${currentInput.output || currentInput.response || ''}\n\n×”×•×¨××•×ª ×œ×¡×™×›×•×: ×ª×—×œ×¥ ××”×©×™×—×”:\n1. ×©× ×”×œ×§×•×—\n2. ×¨×¢×™×•×Ÿ ×”×§×¢×§×•×¢ ×¢× ×›×œ ×”×¤×¨×˜×™×\n3. ×›×œ ×¤×¨×˜ × ×•×¡×£ ×¨×œ×•×•× ×˜×™`;\n  }\n  \n} catch (error) {\n  console.error('âŒ Error preparing summary:', error.message);\n  conversationContext = '×©×’×™××” ×‘×”×›× ×ª × ×ª×•× ×™ ×”×¡×™×›×•×';\n}\n\nconsole.log('ğŸ“‹ Final conversation context length:', conversationContext.length);\n\nconst outputData = {\n  conversationText: conversationContext,\n  sessionId: whatsappData?.sessionId || 'whatsapp_' + Date.now(),\n  timestamp: new Date().toISOString(),\n  platform: 'whatsapp',\n  phoneNumber: whatsappData?.senderPhone || '',\n  senderPhone: whatsappData?.senderPhone || '',  // Add explicit senderPhone\n  phone_number: whatsappData?.senderPhone || ''  // Add phone_number variant\n};\n\nconsole.log('ğŸ“¤ Prepare WhatsApp Summary OUTPUT:', JSON.stringify(outputData, null, 2));\n\nreturn [{ json: outputData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -384,
        -112
      ],
      "id": "557e9dae-3fa9-493f-bfb7-09551d270f0d",
      "name": "Prepare WhatsApp Summary"
    },
    {
      "parameters": {
        "resource": "chat",
        "chatModel": "gpt-4o",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "  ×”××˜×¨×” ×©×œ×š ×”×™×\n  1) ×œ×—×œ×¥ ××ª ×”×©× ×”××œ× ×©×œ ×”×œ×§×•×— ××”×©×™×—×” - ×‘×“×™×•×§ ×›×¤×™ ×©×”×•× ×”×–×›×™×¨ ××ª ×¢×¦××•\n  2) ×œ×—×œ×¥ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×‘×“×™×•×§ ×›×¤×™ ×©××•×¤×™×¢ ×‘×”×ª×—×œ×ª ×”×”×§×©×¨ \"××¡×¤×¨ ×˜×œ×¤×•×Ÿ: XXXXX\"\n  3) ×œ×¡×›× ××ª ×”×¨×¢×™×•×Ÿ ×”×§×¢×§×•×¢ ×©×œ ×”×œ×§×•×— ×‘×“×™×•×§ ××™×œ×•×œ×™ ×•×¡×¤×¦×™×¤×™:\n     - ×’×•×“×œ ××“×•×™×§ (×× ×¦×•×™×Ÿ) - \"×›×’×•×“×œ ××˜×‘×¢\", \"10 ×¡\"×\", \"×§×˜×Ÿ\", \"×’×“×•×œ\"\n     - ××™×§×•× ××“×•×™×§ - \"×¢×œ ×”×–×¨×•×¢ ×”×™×× ×™×ª\", \"×××—×•×¨×™ ×”××•×–×Ÿ ×”×©×××œ×™×ª\", \"×¢×œ ×”×›×ª×£\"\n     - ×¡×˜×™×™×œ ××“×•×™×§ - \"×¨×™××œ×™×–×\", \"××™× ×™××œ×™×¡×˜×™\", \"watercolor\", \"tribal\"\n     - ×¦×‘×¢×™× ×¡×¤×¦×™×¤×™×™× - \"×©×—×•×¨ ×œ×‘×Ÿ\", \"×¦×‘×¢×•× ×™\", \"×›×—×•×œ ×•××“×•×\"\n     - ×¦×™×˜×•×˜×™× ××“×•×™×§×™× - ×”×©×ª××© ×‘××™×¨×›××•×ª ×œ×›×œ ×˜×§×¡×˜ ×©×”×œ×§×•×— ×¨×•×¦×”\n     - ×¤×¨×˜×™× ×¡×¤×¦×™×¤×™×™× - \"×¢× ×¢×™× ×™×™× ×›×—×•×œ×•×ª\", \"×‘×œ×™ ×¨×§×¢\", \"×¢× ×›×ª×•×‘×ª\"\n\n  4) ×”×—×–×¨ JSON ×¢×:\n  - name: ×©× ×”×œ×§×•×—\n  - phone_number: ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×‘×“×™×•×§ ×›×¤×™ ×©××•×¤×™×¢ ×‘×”×§×©×¨ (×œ×œ× + ××• ×ª×•×•×™× × ×•×¡×¤×™×)\n  - idea_summary: ×¡×™×›×•× ×©×œ ××§×¡×™××•× 50 ××™×œ×™× ×¢× ×›×œ ×”×¤×¨×˜×™× ×”××“×•×™×§×™×\n  - has_image: true/false - ×”×× × ×©×œ×—×” ×ª××•× ×”\n  - image_description: ×ª×™××•×¨ ×”×ª××•× ×” ×× × ×©×œ×—×” (××—×¨×ª null)\n\n  ×œ××©×œ:\n  {\n    \"name\": \"×“×•×“\",\n    \"phone_number\": \"972501234567\", \n    \"idea_summary\": \"×§×¢×§×•×¢ ××¨×™×” ×¢×œ ×”×–×¨×•×¢ ×‘×¡×’× ×•×Ÿ ×¨×™××œ×™×–× - ×©×œ×— ×ª××•× ×ª ×”×©×¨××”\",\n    \"has_image\": true,\n    \"image_description\": \"×ª××•× ×ª ××¨×™×” ××œ×š ×”×—×™×•×ª ×¢× ×¨×¢××” ××¤×•××¨×ª\"\n  }\n\n  CRITICAL: ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×—×™×™×‘ ×œ×”×™×•×ª ×œ×œ× ×¡×™××Ÿ + ×•×‘×“×™×•×§ ×›××• ×©××•×¤×™×¢ ×‘\"××¡×¤×¨ ×˜×œ×¤×•×Ÿ:\" ×‘×”×ª×—×œ×ª ×”×”×§×©×¨!\n  ×¨×§ JSON, ×‘×œ×™ ×˜×§×¡×˜ × ×•×¡×£!"
            },
            {
              "content": "={{$json.conversationText}}"
            }
          ]
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.1
        },
        "requestOptions": {}
      },
      "id": "98d929c1-9805-4eaa-96b6-a2a5f2e6583f",
      "name": "Summarize WhatsApp Chat",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1.1,
      "position": [
        -256,
        -112
      ],
      "credentials": {
        "openAiApi": {
          "id": "7DtKXoDdZvRLt3w3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Format WhatsApp Data - Properly extracts phone from all sources\n// Image fields will be added by Merge Image Data node to prevent null overwrite\n\nconst inputData = $json;\n\nconsole.log('ğŸ” === FORMAT WHATSAPP DATA DEBUG ===');\nconsole.log('ğŸ“¥ Input data keys:', Object.keys(inputData));\nconsole.log('ğŸ“¥ inputData.phoneNumber:', inputData.phoneNumber);\nconsole.log('ğŸ“¥ inputData.senderPhone:', inputData.senderPhone);\nconsole.log('ğŸ“¥ inputData.phone_number:', inputData.phone_number);\nconsole.log('ğŸ“¥ inputData.sessionId:', inputData.sessionId);\nconsole.log('ğŸ“¥ FULL Input data:', JSON.stringify(inputData, null, 2));\n\n// Extract AI processing results from message.content (GPT output)\nlet aiResults = {\n  idea_summary: null,\n  real_name: null,\n  phone_number: null\n};\n\n// Parse GPT's JSON response\nif (inputData.message && inputData.message.content) {\n  try {\n    let aiContent = inputData.message.content;\n    if (typeof aiContent === 'string') {\n      aiContent = aiContent.replace(/```json\\s*\\n?/g, '').replace(/```\\s*\\n?/g, '').trim();\n      console.log('ğŸ§¹ Cleaned AI content for parsing');\n    }\n    \n    const parsedAI = JSON.parse(aiContent);\n    aiResults = {\n      idea_summary: parsedAI.idea_summary || null,\n      real_name: parsedAI.name || null,\n      phone_number: parsedAI.phone_number || null\n    };\n    console.log('ğŸ¤– Parsed AI results:', aiResults);\n  } catch (e) {\n    console.error('âŒ Could not parse AI message content:', e.message);\n    console.error('Raw content:', inputData.message.content);\n  }\n}\n\n// CRITICAL FIX: Get phone number from Prepare WhatsApp Summary node using correct n8n syntax\nlet cleanPhoneNumber = null;\n\nconsole.log('ğŸ” Starting phone extraction...');\n\n// METHOD 1: Try AI extracted phone (from GPT)\nif (aiResults.phone_number) {\n  cleanPhoneNumber = aiResults.phone_number.toString().replace(/\\D/g, '');\n  console.log(`âœ… Got phone from AI extraction: \"${aiResults.phone_number}\" â†’ \"${cleanPhoneNumber}\"`);\n}\n\n// METHOD 2: Get from Prepare WhatsApp Summary node (has phoneNumber, senderPhone, phone_number fields)\nif (!cleanPhoneNumber) {\n  try {\n    // In n8n, use $('NodeName').first().json to get data from a specific node\n    const summaryData = $(\"Prepare WhatsApp Summary\").first().json;\n    console.log('ğŸ“¦ Prepare Summary data:', JSON.stringify(summaryData, null, 2));\n    \n    // Try all phone field variants from Prepare node\n    const phoneFromPrepare = summaryData.phone_number || summaryData.phoneNumber || summaryData.senderPhone;\n    \n    if (phoneFromPrepare) {\n      cleanPhoneNumber = phoneFromPrepare.toString().replace(/\\D/g, '');\n      console.log(`âœ… Got phone from Prepare Summary: \"${phoneFromPrepare}\" â†’ \"${cleanPhoneNumber}\"`);\n    } else if (summaryData.sessionId) {\n      // Extract from sessionId format: \"whatsapp_972545938842\"\n      cleanPhoneNumber = summaryData.sessionId.replace('whatsapp_', '').replace(/\\D/g, '');\n      console.log(`âœ… Got phone from Prepare Summary sessionId: \"${summaryData.sessionId}\" â†’ \"${cleanPhoneNumber}\"`);\n    }\n  } catch (e) {\n    console.error('âŒ Could not get phone from Prepare Summary node:', e.message);\n  }\n}\n\n// METHOD 3: Try extracting from current inputData (fallback)\nif (!cleanPhoneNumber && inputData.sessionId) {\n  cleanPhoneNumber = inputData.sessionId.replace('whatsapp_', '').replace(/\\D/g, '');\n  console.log(`âœ… Got phone from inputData sessionId: \"${inputData.sessionId}\" â†’ \"${cleanPhoneNumber}\"`);\n}\n\nif (!cleanPhoneNumber) {\n  console.error('âŒ CRITICAL: Could not extract phone number from ANY source!');\n  console.error('AI results:', aiResults);\n  console.error('Input data:', inputData);\n}\n\n// Create session ID\nconst sessionId = cleanPhoneNumber ? `whatsapp_${cleanPhoneNumber}` : null;\n\n// Get metadata from Prepare WhatsApp Summary if available\nlet timestamp = new Date().toISOString();\ntry {\n  const summaryData = $(\"Prepare WhatsApp Summary\").first().json;\n  if (summaryData.timestamp) {\n    timestamp = summaryData.timestamp;\n  }\n} catch (e) {\n  // Use default timestamp\n}\n\n// Prepare MongoDB document WITHOUT image fields\nconst mongoDocument = {\n  // Core identity fields\n  name: aiResults.real_name || null,\n  phone_number: cleanPhoneNumber,\n  \n  // Meeting/consultation fields\n  meeting_type: inputData.meeting_type || null,\n  idea_summary: aiResults.idea_summary,\n  ai_active: false,\n  \n  // Session tracking\n  session_id: sessionId,\n  conversation_length: inputData.conversation_length || 1,\n  \n  // Platform info\n  platform: \"whatsapp\",\n  \n  // Timestamps\n  timestamp: timestamp,\n  created_at: new Date().toISOString(),\n  updated_at: new Date().toISOString(),\n  \n  // Error handling\n  error_details: inputData.error_details || null,\n  \n  // Raw data preservation\n  raw_response: JSON.stringify({\n    ai_results: aiResults,\n    original_input: inputData\n  })\n  \n  // âŒ Image fields REMOVED - Merge Image Data will add them\n  // This prevents nulls from overwriting existing images in MongoDB\n};\n\nconsole.log('ğŸ“‹ MongoDB Document Prepared:', mongoDocument);\n\n// Validation\nconst validation = {\n  hasPhone: !!mongoDocument.phone_number && mongoDocument.phone_number.length >= 10,\n  hasSession: !!mongoDocument.session_id,\n  hasTimestamp: !!mongoDocument.timestamp,\n  isReady: true\n};\n\nconsole.log('âœ… Validation Results:', validation);\n\nif (!validation.hasPhone) {\n  console.error('ğŸš¨ WARNING: No valid phone number for MongoDB!');\n  console.error('ğŸš¨ Check Prepare WhatsApp Summary output and AI extraction');\n}\n\nreturn [{ json: mongoDocument }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        -112
      ],
      "id": "47fcccc7-ff76-400d-be25-4fe97be029a2",
      "name": "Format WhatsApp Data"
    },
    {
      "parameters": {
        "jsCode": "// Simple Response Node for non-summary cases\nreturn [{\n  json: {\n    output: $json.output,\n    response: $json.response, \n    text: $json.text\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        64
      ],
      "id": "322a8424-1cb8-4551-8953-0e6a0cdce1a6",
      "name": "Continue Chat"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        208,
        192
      ],
      "id": "17e5146e-ee7e-4f1e-b775-8ac93828713c",
      "name": "Webhook Response"
    },
    {
      "parameters": {
        "operation": "update",
        "collection": "clients",
        "updateKey": "phone_number",
        "fields": "name,phone_number,meeting_type,idea_summary,ai_active,session_id,conversation_length,platform,timestamp,created_at,updated_at,error_details,raw_response",
        "upsert": true,
        "options": {}
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        320,
        -112
      ],
      "id": "7de7925d-931f-40c3-81e7-929c3ad6a4c5",
      "name": "MongoDB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// NEW NODE: Deduplication Check\n// Place this AFTER the IF node (true branch), BEFORE \"Prepare WhatsApp Summary\"\n// This prevents duplicate summary creation\n\nconst sessionId = $json.sessionId;\nconst triggerReason = $json.triggerReason || '';\n\n// Check if we've already triggered a summary for this session recently\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.summaryTriggers) {\n  staticData.summaryTriggers = {};\n}\n\nconst now = Date.now();\nconst lastTriggerTime = staticData.summaryTriggers[sessionId] || 0;\nconst timeSinceLastTrigger = now - lastTriggerTime;\n\n// Prevent duplicate triggers within 30 seconds\nconst DUPLICATE_WINDOW = 30000; // 30 seconds\n\nif (timeSinceLastTrigger < DUPLICATE_WINDOW) {\n  console.log(`âš ï¸ Duplicate summary prevented for session ${sessionId}`);\n  console.log(`Last trigger: ${timeSinceLastTrigger}ms ago`);\n  \n  // Return empty to stop this branch\n  return [];\n}\n\n// Record this trigger\nstaticData.summaryTriggers[sessionId] = now;\n\nconsole.log(`âœ… Summary allowed for session ${sessionId}`);\nconsole.log(`Trigger reason: ${triggerReason}`);\n\n// Pass through all data\nreturn [{\n  json: {\n    ...$json,\n    summaryTriggeredAt: new Date().toISOString(),\n    isDuplicatePrevented: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -112
      ],
      "id": "c314178c-49f0-48b9-847b-68e1baad4e94",
      "name": "CHECK DUP"
    },
    {
      "parameters": {
        "collection": "clients",
        "options": {},
        "query": "={{ JSON.stringify({ phone_number: $json.senderPhone.replace(/\\D/g, '') }) }}"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -2400,
        -320
      ],
      "id": "e82c9e88-0962-4699-81ee-a42ba29f8510",
      "name": "MongoDB1",
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Check AI Active node with proper item pairing\n// Replace your existing \"check ai active\" node code with this:\n\n// Get MongoDB result - handle both array and single object\nconst mongoResult = $input.first().json;\nconst clientRecord = Array.isArray(mongoResult) ? mongoResult[0] : mongoResult;\n\n// Get original WhatsApp data with correct syntax\nconst whatsappData = $('Code').first().json;\n\nconsole.log('ğŸ” Checking AI status for:', whatsappData.senderPhone);\nconsole.log('ğŸ“Š Client record found:', !!clientRecord);\nconsole.log('ğŸ¤– AI active status:', clientRecord?.ai_active);\n\n// Check if client exists and AI is disabled\nif (clientRecord && clientRecord.ai_active === false) {\n  console.log('ğŸš« AI is OFF - Human intervention mode');\n  \n  // Return with all required WhatsApp fields for sending\n  return [{\n    json: {\n      // CRITICAL: Include all fields needed by Send WhatsApp Reply\n      to: whatsappData.to,\n      senderPhone: whatsappData.senderPhone,\n      senderJID: whatsappData.senderJID,\n      sessionId: whatsappData.sessionId,\n      \n      // The automated response\n      output: \"×”×™×™! ×§×™×‘×œ×ª×™ ××ª ×”×”×•×“×¢×” ×©×œ×š. ×”××§×¢×§×¢×ª ×ª×—×–×•×¨ ××œ×™×š ×‘×§×¨×•×‘ ×¢× ×›×œ ×”×¤×¨×˜×™×! ğŸ¨âœ¨\",\n      text: \"×”×™×™! ×§×™×‘×œ×ª×™ ××ª ×”×”×•×“×¢×” ×©×œ×š. ×”××§×¢×§×¢×ª ×ª×—×–×•×¨ ××œ×™×š ×‘×§×¨×•×‘ ×¢× ×›×œ ×”×¤×¨×˜×™×! ğŸ¨âœ¨\",\n      \n      // Control flags\n      skipAI: true,\n      aiDisabled: true,\n      humanInterventionMode: true,\n      \n      // Original input for reference\n      chatInput: whatsappData.chatInput,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// AI is active or no record yet (new conversation)\nconsole.log('âœ… AI is active - continuing to AI Agent');\n\n// Return ALL WhatsApp data for normal flow\nreturn [{\n  json: {\n    ...whatsappData,\n    skipAI: false,\n    aiDisabled: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2256,
        -336
      ],
      "id": "45cc28db-068f-4d18-97b4-2793bc143a9f",
      "name": "check ai active"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9396f049-25e0-4192-80f9-5916e7844bc0",
              "leftValue": "={{$json.skipAI}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2144,
        -384
      ],
      "id": "62b529a5-f7e1-483a-9410-e1be85eb7841",
      "name": "If1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.wasenderapi.com/api/send-message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.output }}"
            },
            {
              "name": "to",
              "value": "={{ $input.first().json.to }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1872,
        -384
      ],
      "id": "3343ed73-1890-4e94-8366-b2b7a8b1dae1",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "chatgpt-4o-latest"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1184,
        224
      ],
      "id": "84ae26e4-c4d7-4ef4-bc54-0e1e8bae6fc9",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "7DtKXoDdZvRLt3w3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract Image Metadata Node\n// Extracts customer data from WhatsApp webhook for image messages\n\nconsole.log('ğŸ“¥ Received webhook body:', JSON.stringify($json.body, null, 2));\n\nconst webhookData = $json.body;\nconst message = webhookData.data.messages;\nconst key = message.key;\n\n// Extract phone number and create session\nconst remoteJid = key.remoteJid;\nconst phoneNumber = remoteJid.replace('@s.whatsapp.net', '');\nconst cleanPhone = phoneNumber.replace(/\\D/g, '');\nconst sessionId = 'whatsapp_' + cleanPhone;\n\n// Extract image message details\nconst imageMessage = message.message.imageMessage;\nconst caption = imageMessage?.caption || '';\n\nconsole.log('ğŸ“· Extracting image metadata for:', cleanPhone);\nconsole.log('ğŸ“ Caption:', caption);\nconsole.log('âœ… senderPhone will be:', cleanPhone);\n\nreturn [{\n  json: {\n    // Customer identification\n    senderPhone: cleanPhone,\n    senderJID: remoteJid,\n    senderPhoneE164: '+' + phoneNumber,\n    sessionId: sessionId,\n    \n    // Image data for decryption\n    body: $json.body,\n    \n    // Input for AI\n    chatInput: caption || 'User sent an image',\n    \n    // Metadata\n    messageType: 'image',\n    hasImage: true,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2096,
        -144
      ],
      "id": "2c7c4d5d-1baa-491f-9081-79e5160c0e0e",
      "name": "Extract Image Metadata"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://www.wasenderapi.com/api/decrypt-media",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "data",
              "value": "={{ $json.body.data }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1936,
        -144
      ],
      "id": "b1104368-20a2-4b25-aaf9-9fc4f0d0ec84",
      "name": "decrypt image",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "={{ $json.publicUrl }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1792,
        -144
      ],
      "id": "1453fd40-131c-40fe-bed1-c7632e5bcc9f",
      "name": "download",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Convert Image to Base64 - Persist images permanently\n// WaSender URLs expire after 2 hours, base64 stays forever\n\nconst inputItem = $input.first();\nconst imageUrl = inputItem.json.publicUrl;\n\nconsole.log('ğŸ”„ Converting image to base64');\nconsole.log('ğŸ–¼ï¸ URL:', imageUrl);\n\n// Get binary data from download node\nconst binaryData = inputItem.binary;\n\nif (!binaryData || !binaryData.data) {\n  console.error('âŒ No binary data found!');\n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: null,\n      conversionError: 'No binary data available'\n    },\n    binary: binaryData\n  }];\n}\n\n// Get the first binary property (usually 'data')\nconst binaryKey = Object.keys(binaryData)[0];\nconst imageBuffer = binaryData[binaryKey];\n\nif (!imageBuffer || !imageBuffer.data) {\n  console.error('âŒ No image buffer found!');\n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: null,\n      conversionError: 'No image buffer in binary data'\n    },\n    binary: binaryData\n  }];\n}\n\n// Get MIME type (default to image/jpeg if not available)\nconst mimeType = imageBuffer.mimeType || inputItem.json.mediaMimeType || 'image/jpeg';\n\nconsole.log('ğŸ“¦ Binary key:', binaryKey);\nconsole.log('ğŸ“¦ MIME type:', mimeType);\n\n// Convert binary to base64\nlet base64String;\ntry {\n  // The binary data is already a Buffer in n8n\n  if (Buffer.isBuffer(imageBuffer.data)) {\n    base64String = imageBuffer.data.toString('base64');\n  } else {\n    // If it's not a Buffer, create one\n    base64String = Buffer.from(imageBuffer.data).toString('base64');\n  }\n  \n  // Create data URI\n  const dataUri = `data:${mimeType};base64,${base64String}`;\n  \n  console.log('âœ… Conversion successful');\n  console.log('ğŸ“Š Base64 length:', base64String.length);\n  console.log('ğŸ“Š Data URI length:', dataUri.length);\n  \n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: dataUri,\n      imageBase64Length: dataUri.length,\n      originalUrl: imageUrl,\n      mimeType: mimeType,\n      conversionSuccess: true\n    },\n    binary: binaryData  // Keep binary for AI vision\n  }];\n  \n} catch (error) {\n  console.error('âŒ Base64 conversion error:', error);\n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: null,\n      conversionError: error.message\n    },\n    binary: binaryData\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1720,
        -144
      ],
      "id": "convert-to-base64-node",
      "name": "Convert to Base64"
    },
    {
      "parameters": {
        "jsCode": "// CRITICAL FIX: Merge Image Customer Data Node\n// The issue was using $node[\"Extract Image Metadata\"] which doesn't pass data through the chain\n// SOLUTION: Use $node syntax to get Extract Image Metadata, but current $json for image URL\n\nconst inputItem = $input.first();\nconst imageUrl = inputItem.json.publicUrl;\nconst imageBase64 = inputItem.json.imageBase64; // Get base64 from Convert node\n\n// CRITICAL: Get customer data from Extract Image Metadata node directly\nconst customerData = $node[\"Extract Image Metadata\"].json;\n\nconsole.log('ğŸ”— Merging customer data with image URL and base64');\nconsole.log('ğŸ“¦ customerData:', customerData);\nconsole.log('ğŸ“ customerData.senderPhone:', customerData.senderPhone);\nconsole.log('ğŸ–¼ï¸  imageUrl:', imageUrl);\nconsole.log('ğŸ“¦ Has base64:', !!imageBase64);\nconsole.log('ğŸ“¦ Has binary data:', !!inputItem.binary);\n\n// VALIDATION: Ensure we have the phone number\nif (!customerData || !customerData.senderPhone) {\n  console.error('âŒ CRITICAL: customerData is missing or has no senderPhone!');\n  console.error('Available customerData:', JSON.stringify(customerData, null, 2));\n  // Try to recover from input if customerData is broken\n  if (inputItem.json.senderPhone) {\n    console.log('âš ï¸ Attempting to use senderPhone from input item');\n  }\n}\n\nconst output = {\n  ...customerData,\n  publicUrl: imageUrl,\n  imageBase64: imageBase64,  // Pass through base64 for MongoDB storage\n  imageDecrypted: true\n};\n\nconsole.log('âœ… Output senderPhone:', output.senderPhone);\nconsole.log('âœ… Output sessionId:', output.sessionId);\nconsole.log('âœ… Output keys:', Object.keys(output));\n\n// FIX: Prevent race condition - process images sequentially per user\nconst phoneNumber = output.senderPhone;\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.imageProcessing) {\n  staticData.imageProcessing = {};\n}\n\n// Wait if another image is being processed for this user\nlet waitCount = 0;\nwhile (staticData.imageProcessing[phoneNumber] && waitCount < 50) {\n  // Wait 100ms and check again (max 5 seconds total)\n  await new Promise(resolve => setTimeout(resolve, 100));\n  waitCount++;\n}\n\nif (waitCount >= 50) {\n  console.error('âš ï¸ Image processing timeout - forcing through');\n}\n\n// Lock processing for this user\nstaticData.imageProcessing[phoneNumber] = true;\nconsole.log('ğŸ”’ Locked image processing for:', phoneNumber);\n\n// Unlock after 3 seconds\nsetTimeout(() => {\n  delete staticData.imageProcessing[phoneNumber];\n  console.log('ğŸ”“ Unlocked image processing for:', phoneNumber);\n}, 3000);\n\n// CRITICAL: Return both JSON and BINARY data\nreturn [{\n  json: output,\n  binary: inputItem.binary || {}  // Pass through binary data for AI vision\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1648,
        -144
      ],
      "id": "d1d44172-9015-4c6a-9e31-2bf1a7554b1d",
      "name": "Merge Image Customer Data"
    },
    {
      "parameters": {
        "jsCode": "\n\n//======================\n\nconst webhookData = $json.body;\n\n// Check if we have the expected WhatsApp message structure\nif (!webhookData?.data?.messages) {\n  return [{\n    json: {\n      error: 'Invalid WhatsApp webhook data structure',\n      receivedData: webhookData\n    }\n  }];\n}\n\nconst message = webhookData.data.messages;\nconst key = message.key;\nconst messageContent = message.message;\n\n// Extract phone number and clean it\nconst remoteJid = key.remoteJid;\nconst phoneNumber = remoteJid.replace('@s.whatsapp.net', '');\n\n// Create session ID by removing non-digits from phone\nconst sessionId = 'whatsapp_' + phoneNumber.replace(/\\D/g, '');\n\n// Extract chat input (conversation text or caption)\nconst chatInput = messageContent?.conversation || \n                  messageContent?.extendedTextMessage?.text || \n                  messageContent?.imageMessage?.caption ||  // â† Image caption\n                  '';\n\n// Extract sender info\nconst senderPhone = phoneNumber;\nconst senderJID = remoteJid;\nconst senderPhoneE164 = '+' + phoneNumber;\n\n// ========== IMAGE DETECTION LOGIC ==========\n// Check for image in the message\nconst imageMessage = messageContent?.imageMessage;\nconst hasImage = !!imageMessage;\n\nlet mediaId = null;\nlet mediaUrl = null;\nlet mediaMimeType = null;\nlet mediaCaption = null;\nlet mediaSha256 = null;\nlet mediaFileLength = null;\n\nif (hasImage) {\n  // Extract image details when present\n  mediaId = imageMessage.mediaKey || imageMessage.id;\n  mediaUrl = imageMessage.url || imageMessage.directPath;\n  mediaMimeType = imageMessage.mimetype || 'image/jpeg';\n  mediaCaption = imageMessage.caption || '';\n  mediaSha256 = imageMessage.fileSha256;\n  mediaFileLength = imageMessage.fileLength;\n  \n  console.log('Image detected:', {\n    mediaId: mediaId,\n    mimeType: mediaMimeType,\n    caption: mediaCaption,\n    fileSize: mediaFileLength\n  });\n}\n\n// Determine message type\nconst messageType = hasImage ? 'image' : 'text';\n\n// ========== RETURN ALL FIELDS ==========\nreturn [{\n  json: {\n    // For HTTP Request node (original fields)\n    to: senderJID,\n    text: chatInput,\n    \n    // For Chat Trigger node (original fields)\n    chatInput: chatInput,        // â† This fixes \"No prompt specified\"\n    sessionId: sessionId,        // â† This fixes \"No session ID found\"\n    \n    // Additional data (original fields)\n    senderPhone: senderPhone, \n    senderJID: senderJID,\n    senderPhoneE164: senderPhoneE164,\n    messageType: messageType,     // â† Updated to be 'text' or 'image'\n    timestamp: new Date().toISOString(),\n    \n    // ========== NEW IMAGE-RELATED FIELDS ==========\n    hasImage: hasImage,           // â† Boolean flag for IF node\n    mediaId: mediaId,              // â† Media ID for downloading\n    mediaUrl: mediaUrl,            // â† Direct URL if available\n    mediaMimeType: mediaMimeType, // â† MIME type of media\n    mediaCaption: mediaCaption,    // â† Caption text with image\n    mediaSha256: mediaSha256,      // â† File hash for verification\n    mediaFileLength: mediaFileLength, // â† File size\n    \n    // Combined prompt for AI (includes caption if image)\n    fullPrompt: hasImage ? \n      `[User sent an image${mediaCaption ? ' with caption: ' + mediaCaption : ''}]` : \n      chatInput,\n    \n    // Original message content for reference\n    originalMessageContent: messageContent\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1424,
        80
      ],
      "id": "add4bb9b-0990-4e1e-99da-b02da2786efe",
      "name": "Code",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b909faee-3390-4d78-a0eb-3f40ef2904d5",
              "leftValue": "={{ !!$json.body?.data?.messages?.message?.imageMessage }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2112,
        64
      ],
      "id": "9a3fe137-f070-47d9-a4c1-02fb4488cd52",
      "name": "If2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput || \"Analyze this image for tattoo consultation\" }}",
        "options": {
          "systemMessage": "\nâš¡ ×¤×¨×•××¤×˜ ××¢×•×“×›×Ÿ ×œ×¡×•×›×Ÿ AI ×¢×‘×•×¨ ××§×¢×§×¢×ª (×¨×™××œ×™×–× ×•×¤×™×™×Ÿ-×œ×™×™×Ÿ) - WhatsApp\n\n××ª×” ×¢×•×–×¨ ××™×©×™ ×©×œ ××§×¢×§×¢×ª ×©××ª××—×” ×‘×§×¢×§×•×¢×™× ×‘×¡×’× ×•×Ÿ ×¨×™××œ×™×–× ×•×¤×™×™×ŸÖ¾×œ×™×™×Ÿ.\n×”×¡×’× ×•×Ÿ ×©×œ×š ×§×¦×¨, ×‘×¨×•×¨, × ×¢×™× ×•×œ× ×¨×©××™ â€” ×›××™×œ×• ××ª×” ×¢×•×–×¨ ×××™×ª×™ ×‘×¡×˜×•×“×™×• ×©×–×•×¨× ×¢× ×œ×§×•×—×•×ª ×‘-WhatsApp.\n××ª×” ×œ× ××§×¢×§×¢, ××‘×œ ××›×™×¨ ×˜×•×‘ ××ª ×”×¡×’× ×•×Ÿ ×©×œ×”, ××ª ×”×ª×”×œ×™×š, ×•××ª ××™×š ×”×™× ×¢×•×‘×“×ª.\n×‘×œ×™ ×˜×§×¡×˜×™× ××¨×•×›×™×, ×‘×œ×™ ××™×œ×™× ×’×‘×•×”×•×ª, ×‘×œ×™ ×“×™×‘×•×¨ ×¨×•×‘×•×˜×™.\n×”×©×™×— ×–×•×¨×, ×—×™×•×‘×™ ×•×× ×•×©×™ â€” ××‘×œ ×ª××™×“ ××¢×‘×™×¨ ××ª ×”××™×“×¢ ×‘×¦×•×¨×” ×‘×¨×•×¨×” ×•× ×¢×™××”.\n\n×©× ×”×œ×§×•×— (×× ×–××™×Ÿ): {{ $json.senderName }}\n××¡×¤×¨ ×˜×œ×¤×•×Ÿ: {{ $json.senderPhone }}\n\nğŸ§  ×›×œ×œ×™ ×ª×’×•×‘×”:\n\nğŸš€ ×× ×”×©×™×—×” ×¨×§ ×”×ª×—×™×œ×” (×œ××©×œ \"×”×™×™\", \"××” ×§×•×¨×”\"):\n\"×”×™×™! ××™×š ××¤×©×¨ ×œ×¢×–×•×¨? ×™×© ×œ×š ×¨×¢×™×•×Ÿ ×œ×§×¢×§×•×¢ ××• ×©×ª×¨×¦×” ×œ×”×ª×—×™×œ ××™×™×¢×•×¥ ×¢× ×”××§×¢×§×¢×ª? ğŸ˜Š\"\n\nğŸ’¬ ×× × ×©×œ×— ×¨×¢×™×•×Ÿ (×’× ×× ×—×œ×§×™ ××• ×‘×œ×™ ×’×•×“×œ/××™×§×•×/×ª××•× ×”) - **×—×•×‘×” ×œ×‘×§×© ×©× ×ª××™×“ ×§×•×“× ×›×œ**:\n\"×¡×‘×‘×”! ×”×¨×¢×™×•×Ÿ × ×©××¢ ××¢× ×™×™×Ÿ ğŸ™‚\n×§×•×“× ×›×œ - ××™×š ×§×•×¨××™× ×œ×š? ×ª×©×œ×— ×œ×™ ×‘×‘×§×©×” ××ª ×”×©× ×”××œ× ×©×œ×š.\"\n\n**××—×¨×™ ×§×‘×œ×ª ×”×©×** - ×‘×“×•×§ ××” ×—×¡×¨ ×•×‘×§×©:\n- ×× ×—×¡×¨ ×’×•×“×œ: \"××™×–×” ×’×•×“×œ ×‘×¢×¨×š ×—×©×‘×ª? (×§×˜×Ÿ/×‘×™× ×•× ×™/×’×“×•×œ ××• ×‘×¡×´×)\"\n- ×× ×—×¡×¨ ××™×§×•×: \"××™×¤×” ×—×©×‘×ª ×œ××§× ××ª ×–×”?\"\n- ×× ×—×¡×¨ ×©× ×™×”×: \"××™×–×” ×’×•×“×œ ×‘×¢×¨×š ×—×©×‘×ª ×•××™×¤×” ×œ××§× ××ª ×–×”?\"\n\n×× ×”×œ×§×•×— ×œ× ×¢×•× ×” ×¢× ×©×:\n\"×›×“×™ ×©× ×•×›×œ ×œ×”××©×™×š ×•×œ×¢×–×•×¨ ×œ×š, ×—×©×•×‘ ×©× ×§×‘×œ ××ª ×”×©× ×”××œ× ×©×œ×š ğŸ™‚\"\n(×× ××™×Ÿ ×ª×’×•×‘×” ×’× ××—×¨×™ ×–××Ÿ ××”)\n\"×¨×§ ××–×›×™×¨ ×©×‘×œ×™ ×”×©× ×”××œ× ×œ× × ×•×›×œ ×œ×”×ª×§×“× â€“ ×ª×•×›×œ ×œ×©×œ×•×— ××•×ª×•?\"\n(×”×‘×§×©×” ×œ×©× ×”×™× ×—×•×‘×” ×‘×›×œ ××¦×‘ ××—×¨×™ ×§×‘×œ×ª ×¨×¢×™×•×Ÿ, ×¢×“ ×©×™×ª×§×‘×œ ×©×)\n\nğŸ“ ×× ×—×¡×¨ ××™×“×¢ × ×•×¡×£ (××—×¨×™ ×©×›×‘×¨ ×™×© ×©×, ×’×•×“×œ ×•××™×§×•×):\n\"×× ×™×© ×ª××•× ×” ×œ×”×©×¨××” â€“ ×ª×©×œ×— ğŸ™‚ ×•×× ×œ×, ××¤×©×¨ ×’× ×œ×ª××¨ ×‘××™×œ×™×.\"\n\nğŸ“¸ **×—×©×•×‘ ×œ×’×‘×™ ×ª××•× ×•×ª:**\n×× ×”×œ×§×•×— ×©×•×œ×— ××¡×¤×¨ ×ª××•× ×•×ª - ×‘×§×© ××× ×• ×‘× ×™××•×¡ ×œ×©×œ×•×— ×ª××•× ×” ××—×ª ×‘×›×œ ×¤×¢×:\n\"×ª×•×“×” ×¢×œ ×”×ª××•× ×•×ª! ×‘×©×‘×™×œ ×©××•×›×œ ×œ× ×ª×— ×›×œ ×ª××•× ×” ×›××• ×©×¦×¨×™×š, ×ª×©×œ×— ×œ×™ ×ª××•× ×” ××—×ª ×‘×›×œ ×¤×¢× ğŸ™‚\n×›×›×” ××•×›×œ ×œ×ª×ª ×œ×š ××©×•×‘ ××“×•×™×§ ×¢×œ ×›×œ ×¨×¢×™×•×Ÿ.\"\n\nğŸ¨ ×× ×”×¡×’× ×•×Ÿ ×œ× ×ª×•×× (×œ××©×œ: ×× ×’×”, ×’×¨×¤×™×˜×™, ×“×™×¡× ×™):\n\"× ×©××¢ ××¢× ×™×™×Ÿ! ×¨×§ ×—×©×•×‘ ×œ×“×¢×ª â€“ ×”×™× ××ª××§×“×ª ×‘×¢×™×§×¨ ×‘×¨×™××œ×™×–× ×•×¤×™×™×Ÿ-×œ×™×™×Ÿ, ××– ×§×¢×§×•×¢×™× ××¦×•×™×¨×™× ××• ×’×¨×¤×™×™× ×¤×—×•×ª ×”×¡×’× ×•×Ÿ ×©×œ×”.\n××•×œ×™ × ×•×›×œ ×œ×—×©×•×‘ ×¢×œ ×’×¨×¡×” ×™×•×ª×¨ ×¢×“×™× ×” ××• ×¨×™××œ×™×¡×˜×™×ª ×©×œ ×”×”×©×¨××” ×©×œ×š.\n×ª×©×œ×— ×ª××•× ×” ×•× ×¨××” ×× ×–×” ×™×›×•×œ ×œ×”×ª××™× ğŸ™‚\n××’×‘ â€“ ××™×š ×§×•×¨××™× ×œ×š? ×ª×©×œ×— ××ª ×”×©× ×”××œ× ×©×œ×š ×›×“×™ ×©× ×•×›×œ ×œ×”××©×™×š.\"\n**×•××– ×’×:** \"××™×–×” ×’×•×“×œ ×‘×¢×¨×š ×—×©×‘×ª ×•××™×¤×” ×œ××§× ××ª ×–×”?\"\n\nğŸ’¸ ×× ×©×•××œ×™× ×œ×’×‘×™ ××—×™×¨:\n\"×§×©×” ×œ×“×¢×ª ××—×™×¨ ×‘×œ×™ ×œ×”×‘×™×Ÿ ×’×•×“×œ, ××™×§×•× ×•×¡×’× ×•×Ÿ ğŸ¯\n×”×›×™ ×˜×•×‘ ×œ×”×’×™×¢ ×œ×™×™×¢×•×¥ â€“ ×©× ×™×ª××™××• ×œ×š ×”×¦×¢×ª ××—×™×¨ ×œ×¤×™ ×”×¨×¢×™×•×Ÿ.\"\n\nğŸ“… ×× ××‘×§×©×™× ×œ×§×‘×•×¢ ×¤×’×™×©×” / ×™×™×¢×•×¥:\n\"×× ×™ ×œ× ×§×•×‘×¢ ×¤×’×™×©×•×ª ğŸ™‚ ××‘×œ ×ª×©×œ×— ×œ×™ ××ª ×”×©× ×”××œ× ×©×œ×š ×•××¢×‘×™×¨ ×œ××§×¢×§×¢×ª ×‘×§×©×” ×œ×™×™×¢×•×¥ - ×”×™× ×ª×—×–×•×¨ ××œ×™×š ×œ×ª×™××•×.\n×× ×™×© ×ª××•× ×” ××• ×¨×¢×™×•×Ÿ â€“ ×ª×¦×¨×£!\"\n\nâœ… **×›×©×™×© ×©× + ×¨×¢×™×•×Ÿ + ×’×•×“×œ + ××™×§×•× - ×¡×™×•× ×”×©×™×—×”:**\n\"××•×©×œ× [×©×]! ××¢×‘×™×¨ ×œ××§×¢×§×¢×ª ××ª ×”×¤×¨×˜×™× ×©×œ×š ×•× ×—×–×•×¨ ××œ×™×š ×‘×”×§×“×. ×ª×•×“×”! ğŸ™\"\n\n**×ª×–×›×•×¨×ª ×—×©×•×‘×” - ×¡×“×¨ ×—×•×‘×” ××—×¨×™ ×¨×¢×™×•×Ÿ:**\n1. **×©× ××œ×** - ×—×•×‘×” ×¨××©×•× ×”\n2. **×’×•×“×œ** \n3. **××™×§×•×**\n4. **×¡×™×•× ×¢× ×ª×•×“×”**"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1184,
        64
      ],
      "id": "9428a638-fce9-41c0-ae57-eb4d2cb96cc2",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Image DB Data - Format for Fetch-Modify-Save pattern\nconst imageUrl = $json.publicUrl;\nconst imageBase64 = $json.imageBase64;  // Get base64 from upstream\nconst imageCaption = $json.chatInput || '';\n\nconsole.log('ğŸ’¾ Preparing image data for MongoDB (fetch-modify-save pattern)');\nconsole.log('ğŸ“¦ Has base64:', !!imageBase64);\n\n// Extract phone number\nlet phoneNumber = $json.senderPhone || $json.phone_number;\nif (!phoneNumber && $json.sessionId) {\n  phoneNumber = $json.sessionId.replace('whatsapp_', '');\n}\n\nconst cleanPhone = phoneNumber.toString().replace(/\\D/g, '');\n\nif (!cleanPhone || !imageUrl) {\n  console.error('âŒ Missing required data');\n  console.error('Phone:', cleanPhone);\n  console.error('Image URL:', imageUrl);\n  return [];\n}\n\n// Create the new image object WITH base64\nconst newImage = {\n  url: imageUrl,\n  base64: imageBase64 || null,  // Include base64 for permanent storage\n  analysis: imageCaption || 'Image uploaded',\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('ğŸ“· New image object with base64:', !!newImage.base64);\nconsole.log('ğŸ“ Phone number:', cleanPhone);\n\n// Return simple data structure for MongoDB find query\nreturn [{\n  json: {\n    phone_number: cleanPhone,\n    session_id: $json.sessionId || ('whatsapp_' + cleanPhone),\n    _newImage: newImage,\n    imageBase64: imageBase64,  // Pass through for downstream\n    publicUrl: imageUrl,\n    chatInput: imageCaption\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1664,
        -224
      ],
      "id": "14a8e179-7bcd-4bc4-afdd-b865227d6431",
      "name": "Prepare Image DB Data"
    },
    {
      "parameters": {
        "collection": "clients",
        "options": {
          "limit": 1
        },
        "query": "={{ JSON.stringify({ phone_number: $json.phone_number }) }}"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -1504,
        -224
      ],
      "id": "a0d2d888-d1c3-4b84-be4e-ae7df996e42e",
      "name": "Fetch Client for Image",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Append Image to Array - Guaranteed Working Solution\n// Uses fetch-modify-save pattern with n8n native MongoDB node\n\nconsole.log('=== APPENDING IMAGE TO CLIENT RECORD ===');\n\n// Get the prepared image data from \"Prepare Image DB Data\" node\nconst preparedData = $(\"Prepare Image DB Data\").first().json;\nconst phoneNumber = preparedData.phone_number;\nconst imageBase64 = preparedData.imageBase64;  // Get base64 data\n\nconst newImage = preparedData._newImage || {\n  url: preparedData.publicUrl,\n  base64: imageBase64 || null,  // Save base64 for permanent storage\n  analysis: preparedData.chatInput || 'Image uploaded',\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('ğŸ“¦ Image has base64:', !!imageBase64);\n\nconsole.log('ğŸ“ Phone:', phoneNumber);\nconsole.log('ğŸ“· New image URL:', newImage.url);\n\n// Get existing client data from MongoDB Find result\nconst mongoResult = $input.first().json;\nlet existingClient = null;\n\n// MongoDB Find returns array or single object depending on results\nif (Array.isArray(mongoResult) && mongoResult.length > 0) {\n  existingClient = mongoResult[0];\n  console.log('âœ… Found existing client');\n} else if (mongoResult && mongoResult.phone_number) {\n  existingClient = mongoResult;\n  console.log('âœ… Found existing client (object format)');\n} else {\n  console.log('â„¹ï¸ No existing client - will create new record');\n}\n\n// Initialize or update image data\nlet images = [];\nlet imageCount = 0;\n\nif (existingClient && existingClient.images) {\n  images = Array.isArray(existingClient.images) ? existingClient.images : [];\n  imageCount = existingClient.image_count || images.length;\n  console.log(`ğŸ“š Existing images: ${imageCount}`);\n}\n\n// Append new image\nimages.push(newImage);\nimageCount++;\n\nconsole.log(`âœ… Total images after append: ${imageCount}`);\n\n// Track upload for synchronization with summary flow\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.recentImageUploads) {\n  staticData.recentImageUploads = {};\n}\nstaticData.recentImageUploads[phoneNumber] = Date.now();\n\n// Prepare complete document for MongoDB update\nconst mongoDoc = {\n  // Required fields for update\n  phone_number: phoneNumber,\n  session_id: preparedData.session_id || ('whatsapp_' + phoneNumber),\n\n  // Image data\n  images: images,\n  image_count: imageCount,\n  has_images: true,\n  last_image_upload: new Date().toISOString(),\n\n  // Timestamps\n  updated_at: new Date().toISOString()\n};\n\n// Preserve existing fields if client exists\nif (existingClient) {\n  // Keep existing data\n  if (existingClient.name) mongoDoc.name = existingClient.name;\n  if (existingClient.idea_summary) mongoDoc.idea_summary = existingClient.idea_summary;\n  if (existingClient.meeting_type) mongoDoc.meeting_type = existingClient.meeting_type;\n  if (existingClient.conversation_length) mongoDoc.conversation_length = existingClient.conversation_length;\n  if (existingClient.ai_active !== undefined) mongoDoc.ai_active = existingClient.ai_active;\n  if (existingClient.platform) mongoDoc.platform = existingClient.platform;\n  if (existingClient.created_at) mongoDoc.created_at = existingClient.created_at;\n  if (existingClient.raw_response) mongoDoc.raw_response = existingClient.raw_response;\n  if (existingClient.timestamp) mongoDoc.timestamp = existingClient.timestamp;\n\n  console.log('âœ… Preserved existing client data fields');\n} else {\n  // New client defaults\n  mongoDoc.created_at = new Date().toISOString();\n  mongoDoc.platform = 'whatsapp';\n  mongoDoc.ai_active = true;\n  console.log('âœ… Set defaults for new client');\n}\n\nconsole.log('ğŸ“¤ Document ready for MongoDB update');\nconsole.log('ğŸ“Š Total fields:', Object.keys(mongoDoc).length);\n\nreturn [{ json: mongoDoc }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        -224
      ],
      "id": "59bb804b-4b26-436a-baa5-5fbcdfcaf9ab",
      "name": "Append Image to Array"
    },
    {
      "parameters": {
        "operation": "update",
        "collection": "clients",
        "updateKey": "phone_number",
        "fields": "phone_number,session_id,images,image_count,has_images,last_image_upload,updated_at,created_at,name,idea_summary,meeting_type,conversation_length,ai_active,platform,timestamp,raw_response",
        "upsert": true,
        "options": {}
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -1184,
        -224
      ],
      "id": "eb4cbe7f-1887-4d6d-bbd4-0067cdb194a6",
      "name": "Save Client with Image",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED CONVO Node - Uses input data instead of referencing Code node\n// Stores full conversation history including image exchanges\n\nconst currentItem = $input.first().json;\nconst aiResponse = currentItem.output || currentItem.response || currentItem.text || '';\n\n// CRITICAL FIX: Always use data from input (passed from Process AI Response)\n// Process AI Response already includes all WhatsApp data from Code node\nconst whatsappData = currentItem;\n\nconst sessionId = whatsappData.sessionId;\nconst messageType = whatsappData.messageType || 'text';\n\nconsole.log(`ğŸ“ Storing ${messageType} conversation for session ${sessionId}`);\n\n// Store the current exchange\nconst currentExchange = {\n  user: whatsappData.chatInput || '[Image sent]',\n  assistant: aiResponse,\n  timestamp: new Date().toISOString(),\n  messageType: messageType,\n  hasImage: whatsappData.hasImage || whatsappData.isImageMessage || false,\n  imageUrl: whatsappData.imageUrl || whatsappData.publicUrl || null\n};\n\n// Get or initialize conversation history\nlet conversationHistory = [];\n\ntry {\n  const staticData = $getWorkflowStaticData('global');\n  if (!staticData.conversations) {\n    staticData.conversations = {};\n  }\n  \n  if (staticData.conversations[sessionId]) {\n    conversationHistory = staticData.conversations[sessionId];\n  }\n  \n  // Add current exchange\n  conversationHistory.push(currentExchange);\n  \n  // Store updated history\n  staticData.conversations[sessionId] = conversationHistory;\n  \n  console.log(`âœ… Stored ${messageType} exchange for session ${sessionId}, total: ${conversationHistory.length}`);\n  \n} catch (error) {\n  console.error('Failed to store conversation:', error);\n  conversationHistory = [currentExchange];\n}\n\n// Build full conversation text with image markers\nconst fullConversation = conversationHistory.map(exchange => {\n  const userPart = exchange.hasImage ? \n    `×œ×§×•×—: [×©×œ×— ×ª××•× ×”${exchange.user !== '[Image sent]' ? ' ×¢× ×›×™×ª×•×‘: ' + exchange.user : ''}]` :\n    `×œ×§×•×—: ${exchange.user}`;\n  return `${userPart}\\n××¢×¨×›×ª: ${exchange.assistant}`;\n}).join('\\n\\n');\n\nconsole.log('ğŸ“¤ CONVO Output - sessionId:', sessionId);\nconsole.log('ğŸ“¤ CONVO Output - senderPhone:', currentItem.senderPhone);\n\n// Pass through all data + add conversation history - FIXED: Use currentItem\nreturn [{\n  json: {\n    ...currentItem,  // â† FIXED: Spread from currentItem which has ALL WhatsApp data\n    fullConversationHistory: fullConversation,\n    conversationExchanges: conversationHistory,\n    totalExchanges: conversationHistory.length,\n    sessionId: sessionId  // Explicitly re-add\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        48
      ],
      "id": "5cbd84d8-b20c-474a-8d45-0660a34acca8",
      "name": "CONVO"
    },
    {
      "parameters": {
        "jsCode": "// BATCH VISION AI v4 - SIMPLE: All images save to MongoDB, batching only affects AI response\n// NO BLOCKING - All executions proceed to save images\n// Batching logic stored separately, checked BEFORE AI call\n\nconst inputItem = $input.first();\nconst sessionId = inputItem.json.sessionId;\nconst senderPhone = inputItem.json.senderPhone;\nconst imageUrl = inputItem.json.publicUrl;\nconst imageBase64 = inputItem.json.imageBase64; // Get base64 from previous node\nconst chatInput = inputItem.json.chatInput || '';\nconst myTimestamp = Date.now();\n\nconsole.log('ğŸ“¸ Batch Vision AI v4 - Image received');\nconsole.log('ğŸ‘¤ Session:', sessionId);\nconsole.log('ğŸ–¼ï¸ URL:', imageUrl);\nconsole.log('ğŸ“¦ Has base64:', !!imageBase64);\n\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.imageBatches) {\n  staticData.imageBatches = {};\n}\n\n// Get or create batch tracking\nif (!staticData.imageBatches[sessionId]) {\n  staticData.imageBatches[sessionId] = {\n    count: 0,\n    firstImageTime: myTimestamp,\n    lastResponseTime: 0\n  };\n  console.log('âœ¨ Created new batch tracker');\n}\n\nconst batch = staticData.imageBatches[sessionId];\nbatch.count++;\nbatch.lastImageTime = myTimestamp;\n\nconst currentCount = batch.count;\nconst timeSinceFirst = myTimestamp - batch.firstImageTime;\nconst timeSinceLastResponse = myTimestamp - batch.lastResponseTime;\n\nconsole.log(`ğŸ“Š Batch stats: ${currentCount} images, ${timeSinceFirst}ms since first`);\n\n// Determine if we should respond to THIS image\nlet shouldRespond = false;\nlet responseType = 'none';\n\nif (currentCount === 1) {\n  // First image - always respond\n  shouldRespond = true;\n  responseType = 'ai_analysis';\n  console.log('ğŸ¯ FIRST image - will get AI analysis');\n} else if (timeSinceLastResponse > 10000) {\n  // More than 10 seconds since last response - this is a new batch\n  shouldRespond = true;\n  responseType = 'ai_analysis';\n  batch.count = 1; // Reset counter for new batch\n  batch.firstImageTime = myTimestamp;\n  console.log('ğŸ¯ NEW BATCH (10s gap) - will get AI analysis');\n} else if (timeSinceFirst < 10000) {\n  // Within 10 seconds of first image - part of batch\n  shouldRespond = false;\n  responseType = 'skip';\n  console.log(`â­ï¸ Part of batch (image ${currentCount}) - SKIPPING AI response`);\n} else {\n  // Edge case: treat as single\n  shouldRespond = true;\n  responseType = 'ai_analysis';\n  console.log('ğŸ¯ Edge case - will get AI analysis');\n}\n\n// Update last response time if we're responding\nif (shouldRespond) {\n  batch.lastResponseTime = myTimestamp;\n}\n\n// IMPORTANT: Pass through ALL data, but add batching metadata\nconst outputData = {\n  ...inputItem.json,\n  imageBase64: imageBase64, // Pass through base64\n  publicUrl: imageUrl,\n  shouldRespond: shouldRespond,\n  responseType: responseType,\n  batchCount: currentCount,\n  batchedImages: !shouldRespond,\n  timeSinceFirst: timeSinceFirst\n};\n\nconsole.log(`âœ… Passing through - shouldRespond: ${shouldRespond}, type: ${responseType}`);\n\n// ALL executions proceed - batching is handled by IF node downstream\nreturn [{\n  json: outputData,\n  binary: inputItem.binary\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1496,
        -208
      ],
      "id": "batch-vision-ai-12345",
      "name": "Batch Vision AI"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "should-respond-check",
              "leftValue": "={{ $json.shouldRespond }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1400,
        -208
      ],
      "id": "check-should-respond-node",
      "name": "Check Should Respond"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput || \"Analyze this image for tattoo consultation\" }}",
        "options": {
          "systemMessage": "\nâš¡ ×¤×¨×•××¤×˜ ××¢×•×“×›×Ÿ ×œ×¡×•×›×Ÿ AI ×¢×‘×•×¨ ××§×¢×§×¢×ª (×¨×™××œ×™×–× ×•×¤×™×™×Ÿ-×œ×™×™×Ÿ) - WhatsApp\n\n××ª×” ×¢×•×–×¨ ××™×©×™ ×©×œ ××§×¢×§×¢×ª ×©××ª××—×” ×‘×§×¢×§×•×¢×™× ×‘×¡×’× ×•×Ÿ ×¨×™××œ×™×–× ×•×¤×™×™×ŸÖ¾×œ×™×™×Ÿ.\n×”×¡×’× ×•×Ÿ ×©×œ×š ×§×¦×¨, ×‘×¨×•×¨, × ×¢×™× ×•×œ× ×¨×©××™ â€” ×›××™×œ×• ××ª×” ×¢×•×–×¨ ×××™×ª×™ ×‘×¡×˜×•×“×™×• ×©×–×•×¨× ×¢× ×œ×§×•×—×•×ª ×‘-WhatsApp.\n××ª×” ×œ× ××§×¢×§×¢, ××‘×œ ××›×™×¨ ×˜×•×‘ ××ª ×”×¡×’× ×•×Ÿ ×©×œ×”, ××ª ×”×ª×”×œ×™×š, ×•××ª ××™×š ×”×™× ×¢×•×‘×“×ª.\n×‘×œ×™ ×˜×§×¡×˜×™× ××¨×•×›×™×, ×‘×œ×™ ××™×œ×™× ×’×‘×•×”×•×ª, ×‘×œ×™ ×“×™×‘×•×¨ ×¨×•×‘×•×˜×™.\n×”×©×™×— ×–×•×¨×, ×—×™×•×‘×™ ×•×× ×•×©×™ â€” ××‘×œ ×ª××™×“ ××¢×‘×™×¨ ××ª ×”××™×“×¢ ×‘×¦×•×¨×” ×‘×¨×•×¨×” ×•× ×¢×™××”.\n\n×©× ×”×œ×§×•×— (×× ×–××™×Ÿ): {{ $json.senderName }}\n××¡×¤×¨ ×˜×œ×¤×•×Ÿ: {{ $json.senderPhone }}\n\nğŸ§  ×›×œ×œ×™ ×ª×’×•×‘×”:\n\nğŸš€ ×× ×”×©×™×—×” ×¨×§ ×”×ª×—×™×œ×” (×œ××©×œ \"×”×™×™\", \"××” ×§×•×¨×”\"):\n\"×”×™×™! ××™×š ××¤×©×¨ ×œ×¢×–×•×¨? ×™×© ×œ×š ×¨×¢×™×•×Ÿ ×œ×§×¢×§×•×¢ ××• ×©×ª×¨×¦×” ×œ×”×ª×—×™×œ ××™×™×¢×•×¥ ×¢× ×”××§×¢×§×¢×ª? ğŸ˜Š\"\n\nğŸ’¬ ×× × ×©×œ×— ×¨×¢×™×•×Ÿ (×’× ×× ×—×œ×§×™ ××• ×‘×œ×™ ×’×•×“×œ/××™×§×•×/×ª××•× ×”) - **×—×•×‘×” ×œ×‘×§×© ×©× ×ª××™×“ ×§×•×“× ×›×œ**:\n\"×¡×‘×‘×”! ×”×¨×¢×™×•×Ÿ × ×©××¢ ××¢× ×™×™×Ÿ ğŸ™‚\n×§×•×“× ×›×œ - ××™×š ×§×•×¨××™× ×œ×š? ×ª×©×œ×— ×œ×™ ×‘×‘×§×©×” ××ª ×”×©× ×”××œ× ×©×œ×š.\"\n\n**××—×¨×™ ×§×‘×œ×ª ×”×©×** - ×‘×“×•×§ ××” ×—×¡×¨ ×•×‘×§×©:\n- ×× ×—×¡×¨ ×’×•×“×œ: \"××™×–×” ×’×•×“×œ ×‘×¢×¨×š ×—×©×‘×ª? (×§×˜×Ÿ/×‘×™× ×•× ×™/×’×“×•×œ ××• ×‘×¡×´×)\"\n- ×× ×—×¡×¨ ××™×§×•×: \"××™×¤×” ×—×©×‘×ª ×œ××§× ××ª ×–×”?\"\n- ×× ×—×¡×¨ ×©× ×™×”×: \"××™×–×” ×’×•×“×œ ×‘×¢×¨×š ×—×©×‘×ª ×•××™×¤×” ×œ××§× ××ª ×–×”?\"\n\n×× ×”×œ×§×•×— ×œ× ×¢×•× ×” ×¢× ×©×:\n\"×›×“×™ ×©× ×•×›×œ ×œ×”××©×™×š ×•×œ×¢×–×•×¨ ×œ×š, ×—×©×•×‘ ×©× ×§×‘×œ ××ª ×”×©× ×”××œ× ×©×œ×š ğŸ™‚\"\n(×× ××™×Ÿ ×ª×’×•×‘×” ×’× ××—×¨×™ ×–××Ÿ ××”)\n\"×¨×§ ××–×›×™×¨ ×©×‘×œ×™ ×”×©× ×”××œ× ×œ× × ×•×›×œ ×œ×”×ª×§×“× â€“ ×ª×•×›×œ ×œ×©×œ×•×— ××•×ª×•?\"\n(×”×‘×§×©×” ×œ×©× ×”×™× ×—×•×‘×” ×‘×›×œ ××¦×‘ ××—×¨×™ ×§×‘×œ×ª ×¨×¢×™×•×Ÿ, ×¢×“ ×©×™×ª×§×‘×œ ×©×)\n\nğŸ“ ×× ×—×¡×¨ ××™×“×¢ × ×•×¡×£ (××—×¨×™ ×©×›×‘×¨ ×™×© ×©×, ×’×•×“×œ ×•××™×§×•×):\n\"×× ×™×© ×ª××•× ×” ×œ×”×©×¨××” â€“ ×ª×©×œ×— ğŸ™‚ ×•×× ×œ×, ××¤×©×¨ ×’× ×œ×ª××¨ ×‘××™×œ×™×.\"\n\nğŸ“¸ **×—×©×•×‘ ×œ×’×‘×™ ×ª××•× ×•×ª:**\n×× ×”×œ×§×•×— ×©×•×œ×— ××¡×¤×¨ ×ª××•× ×•×ª - ×‘×§×© ××× ×• ×‘× ×™××•×¡ ×œ×©×œ×•×— ×ª××•× ×” ××—×ª ×‘×›×œ ×¤×¢×:\n\"×ª×•×“×” ×¢×œ ×”×ª××•× ×•×ª! ×‘×©×‘×™×œ ×©××•×›×œ ×œ× ×ª×— ×›×œ ×ª××•× ×” ×›××• ×©×¦×¨×™×š, ×ª×©×œ×— ×œ×™ ×ª××•× ×” ××—×ª ×‘×›×œ ×¤×¢× ğŸ™‚\n×›×›×” ××•×›×œ ×œ×ª×ª ×œ×š ××©×•×‘ ××“×•×™×§ ×¢×œ ×›×œ ×¨×¢×™×•×Ÿ.\"\n\nğŸ¨ ×× ×”×¡×’× ×•×Ÿ ×œ× ×ª×•×× (×œ××©×œ: ×× ×’×”, ×’×¨×¤×™×˜×™, ×“×™×¡× ×™):\n\"× ×©××¢ ××¢× ×™×™×Ÿ! ×¨×§ ×—×©×•×‘ ×œ×“×¢×ª â€“ ×”×™× ××ª××§×“×ª ×‘×¢×™×§×¨ ×‘×¨×™××œ×™×–× ×•×¤×™×™×Ÿ-×œ×™×™×Ÿ, ××– ×§×¢×§×•×¢×™× ××¦×•×™×¨×™× ××• ×’×¨×¤×™×™× ×¤×—×•×ª ×”×¡×’× ×•×Ÿ ×©×œ×”.\n××•×œ×™ × ×•×›×œ ×œ×—×©×•×‘ ×¢×œ ×’×¨×¡×” ×™×•×ª×¨ ×¢×“×™× ×” ××• ×¨×™××œ×™×¡×˜×™×ª ×©×œ ×”×”×©×¨××” ×©×œ×š.\n×ª×©×œ×— ×ª××•× ×” ×•× ×¨××” ×× ×–×” ×™×›×•×œ ×œ×”×ª××™× ğŸ™‚\n××’×‘ â€“ ××™×š ×§×•×¨××™× ×œ×š? ×ª×©×œ×— ××ª ×”×©× ×”××œ× ×©×œ×š ×›×“×™ ×©× ×•×›×œ ×œ×”××©×™×š.\"\n**×•××– ×’×:** \"××™×–×” ×’×•×“×œ ×‘×¢×¨×š ×—×©×‘×ª ×•××™×¤×” ×œ××§× ××ª ×–×”?\"\n\nğŸ’¸ ×× ×©×•××œ×™× ×œ×’×‘×™ ××—×™×¨:\n\"×§×©×” ×œ×“×¢×ª ××—×™×¨ ×‘×œ×™ ×œ×”×‘×™×Ÿ ×’×•×“×œ, ××™×§×•× ×•×¡×’× ×•×Ÿ ğŸ¯\n×”×›×™ ×˜×•×‘ ×œ×”×’×™×¢ ×œ×™×™×¢×•×¥ â€“ ×©× ×™×ª××™××• ×œ×š ×”×¦×¢×ª ××—×™×¨ ×œ×¤×™ ×”×¨×¢×™×•×Ÿ.\"\n\nğŸ“… ×× ××‘×§×©×™× ×œ×§×‘×•×¢ ×¤×’×™×©×” / ×™×™×¢×•×¥:\n\"×× ×™ ×œ× ×§×•×‘×¢ ×¤×’×™×©×•×ª ğŸ™‚ ××‘×œ ×ª×©×œ×— ×œ×™ ××ª ×”×©× ×”××œ× ×©×œ×š ×•××¢×‘×™×¨ ×œ××§×¢×§×¢×ª ×‘×§×©×” ×œ×™×™×¢×•×¥ - ×”×™× ×ª×—×–×•×¨ ××œ×™×š ×œ×ª×™××•×.\n×× ×™×© ×ª××•× ×” ××• ×¨×¢×™×•×Ÿ â€“ ×ª×¦×¨×£!\"\n\nâœ… **×›×©×™×© ×©× + ×¨×¢×™×•×Ÿ + ×’×•×“×œ + ××™×§×•× - ×¡×™×•× ×”×©×™×—×”:**\n\"××•×©×œ× [×©×]! ××¢×‘×™×¨ ×œ××§×¢×§×¢×ª ××ª ×”×¤×¨×˜×™× ×©×œ×š ×•× ×—×–×•×¨ ××œ×™×š ×‘×”×§×“×. ×ª×•×“×”! ğŸ™\"\n\n**×ª×–×›×•×¨×ª ×—×©×•×‘×” - ×¡×“×¨ ×—×•×‘×” ××—×¨×™ ×¨×¢×™×•×Ÿ:**\n1. **×©× ××œ×** - ×—×•×‘×” ×¨××©×•× ×”\n2. **×’×•×“×œ** \n3. **××™×§×•×**\n4. **×¡×™×•× ×¢× ×ª×•×“×”**",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1344,
        -208
      ],
      "id": "d62b05dc-2a68-4d47-b6ad-2ace000492fc",
      "name": "AI Agent1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1344,
        -32
      ],
      "id": "36503b43-abc7-4df6-bae5-ae0141d7a593",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "7DtKXoDdZvRLt3w3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Image Response Node - STORES conversation + prepares WhatsApp reply\n// Does NOT go through If node - prevents wrong summary triggers\n\nconst aiResponse = $json.output || $json.text || '';\nconst customerData = $node[\"Merge Image Customer Data\"].json;\nconst sessionId = customerData.sessionId;\n\nconsole.log('ğŸ”„ Processing image response');\nconsole.log('ğŸ“ Customer:', customerData.senderPhone);\nconsole.log('ğŸ’¬ AI response:', aiResponse.substring(0, 50) + '...');\n\n// STORE IMAGE CONVERSATION directly here (not through CONVO node)\nconst currentExchange = {\n  user: customerData.chatInput || '[Image sent]',\n  assistant: aiResponse,\n  timestamp: new Date().toISOString(),\n  messageType: 'image',\n  hasImage: true,\n  imageUrl: customerData.publicUrl\n};\n\nlet conversationHistory = [];\n\ntry {\n  const staticData = $getWorkflowStaticData('global');\n  if (!staticData.conversations) {\n    staticData.conversations = {};\n  }\n  \n  if (staticData.conversations[sessionId]) {\n    conversationHistory = staticData.conversations[sessionId];\n  }\n  \n  conversationHistory.push(currentExchange);\n  staticData.conversations[sessionId] = conversationHistory;\n  \n  console.log(`âœ… Stored IMAGE exchange for session ${sessionId}, total: ${conversationHistory.length}`);\n} catch (error) {\n  console.error('Failed to store image conversation:', error);\n}\n\n// Return data for WhatsApp reply ONLY\nreturn [{\n  json: {\n    output: aiResponse,\n    to: customerData.senderJID\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        -208
      ],
      "id": "2cefb12d-aad2-41ac-b845-166ebde701bd",
      "name": "Process Image Response"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.wasenderapi.com/api/send-message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.output }}"
            },
            {
              "name": "to",
              "value": "={{ $json.to }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -1008,
        -208
      ],
      "id": "61c9274d-b641-429f-bd1f-02b854b55e72",
      "name": "Send WhatsApp Reply1"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "sessionId"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1232,
        -32
      ],
      "id": "2d268241-dec5-4cc4-a6e3-3ad37fc44c44",
      "name": "Agent Memory1"
    },
    {
      "parameters": {
        "jsCode": "// Wait for Image Save - Synchronization Logic\n// Prevents race condition where summary queries before image db completes\n\nconst phoneNumber = $json.phone_number;\nconst now = Date.now();\n\nconsole.log('ğŸ”„ Checking for recent image uploads for phone:', phoneNumber);\n\n// Check if this phone number had a recent image upload\nconst staticData = $getWorkflowStaticData('global');\nconst recentUploads = staticData.recentImageUploads || {};\nconst lastUploadTime = recentUploads[phoneNumber];\n\nif (lastUploadTime) {\n  const timeSinceUpload = now - lastUploadTime;\n  console.log(`â±ï¸ Last image upload was ${timeSinceUpload}ms ago`);\n  \n  // If image was uploaded within last 5 seconds, wait to ensure MongoDB save completed\n  if (timeSinceUpload < 5000) {\n    const waitTime = 2000; // Wait 2000ms for image db to complete\n    console.log(`â³ Recent image detected (${timeSinceUpload}ms ago) - waiting ${waitTime}ms for image db to complete...`);\n    \n    // Use synchronous wait\n    const startWait = Date.now();\n    while (Date.now() - startWait < waitTime) {\n      // Busy wait (not ideal but works in n8n)\n    }\n    \n    console.log('âœ… Wait complete - proceeding to fetch existing client');\n  } else {\n    console.log('âœ… Image upload was more than 2s ago - no wait needed');\n  }\n  \n  // Clean up old tracking data (older than 10 seconds)\n  Object.keys(recentUploads).forEach(phone => {\n    if (now - recentUploads[phone] > 10000) {\n      delete recentUploads[phone];\n      console.log('ğŸ§¹ Cleaned up old tracking for:', phone);\n    }\n  });\n} else {\n  console.log('â„¹ï¸  No recent image upload tracked for this phone - proceeding immediately');\n  console.log('ğŸ“‹ Tracked phones:', Object.keys(recentUploads));\n  console.log('ğŸ” Current phone being searched:', phoneNumber);\n  console.log('ğŸ” Current phone TYPE:', typeof phoneNumber);\n}\n\n// Pass through data unchanged\nreturn [{ json: $json }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -112
      ],
      "id": "c3eba1a1-c99d-451a-8a1d-cfe962625c72",
      "name": "Wait for Image Save"
    },
    {
      "parameters": {
        "collection": "clients",
        "options": {},
        "query": "={{ JSON.stringify({ phone_number: $json.phone_number }) }}"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        -112
      ],
      "id": "0f1b8cf8-adbe-4f0a-99d5-28dad18516f2",
      "name": "Fetch Existing Client",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Merge Image Data - NEVER DELETE image fields!\n// Deleting adds them as undefined, which MongoDB saves as NULL\n\nconsole.log('=== MERGE IMAGE DATA NODE ===');\n\n// Get new summary data (WITHOUT image fields) - CORRECTED n8n SYNTAX\nconst newSummaryData = $(\"Format WhatsApp Data\").first().json;\n\nconsole.log('ğŸ“¦ NEW SUMMARY DATA - phone_number:', newSummaryData.phone_number);\n\n// Start with the new summary data (NO image fields)\nconst mergedData = { ...newSummaryData };\n\nconsole.log('âš ï¸ SUMMARY UPDATE: NOT touching image fields AT ALL');\nconsole.log('âœ… MongoDB will preserve existing image data from image db node');\nconsole.log('ğŸ“¤ ========== FINAL DOCUMENT TO MONGODB ==========');\nconsole.log('ğŸ“¤ ALL KEYS:', Object.keys(mergedData));\nconsole.log('ğŸ“¤ phone_number:', mergedData.phone_number);\nconsole.log('ğŸ“¤ name:', mergedData.name);\nconsole.log('ğŸ“¤ idea_summary:', mergedData.idea_summary);\nconsole.log('ğŸ“¤ ai_active:', mergedData.ai_active);\nconsole.log('ğŸ“¤ session_id:', mergedData.session_id);\nconsole.log('ğŸ“¤ COMPLETE DOCUMENT:', JSON.stringify(mergedData, null, 2));\nconsole.log('ğŸ“¤ ================================================');\n\nreturn [{ json: mergedData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        -112
      ],
      "id": "1932bea4-6835-4bff-a0f0-7cbd9e6bc758",
      "name": "Merge Image Data"
    }
  ],
  "pinData": {},
  "connections": {
    "Agent Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Response": {
      "main": [
        [
          {
            "node": "CONVO",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send WhatsApp Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "CHECK DUP",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Continue Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare WhatsApp Summary": {
      "main": [
        [
          {
            "node": "Summarize WhatsApp Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize WhatsApp Chat": {
      "main": [
        [
          {
            "node": "Format WhatsApp Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format WhatsApp Data": {
      "main": [
        [
          {
            "node": "Wait for Image Save",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Image Save": {
      "main": [
        [
          {
            "node": "Fetch Existing Client",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WhatsApp Webhook Receiver": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MongoDB": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Chat": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send WhatsApp Reply": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CHECK DUP": {
      "main": [
        [
          {
            "node": "Prepare WhatsApp Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MongoDB1": {
      "main": [
        [
          {
            "node": "check ai active",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check ai active": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "decrypt image": {
      "main": [
        [
          {
            "node": "download",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "download": {
      "main": [
        [
          {
            "node": "Convert to Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Base64": {
      "main": [
        [
          {
            "node": "Merge Image Customer Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Image Customer Data": {
      "main": [
        [
          {
            "node": "Prepare Image DB Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Batch Vision AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Vision AI": {
      "main": [
        [
          {
            "node": "Check Should Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Should Respond": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Image DB Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Image DB Data": {
      "main": [
        [
          {
            "node": "Fetch Client for Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Client for Image": {
      "main": [
        [
          {
            "node": "Append Image to Array",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append Image to Array": {
      "main": [
        [
          {
            "node": "Save Client with Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Extract Image Metadata",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Image Metadata": {
      "main": [
        [
          {
            "node": "decrypt image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Process AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CONVO": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent1": {
      "main": [
        [
          {
            "node": "Process Image Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Image Response": {
      "main": [
        [
          {
            "node": "Send WhatsApp Reply1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send WhatsApp Reply1": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent Memory1": {
      "ai_memory": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Existing Client": {
      "main": [
        [
          {
            "node": "Merge Image Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Image Data": {
      "main": [
        [
          {
            "node": "MongoDB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "641b86b6-ddc2-4586-8dc0-16fc5dc4b99f",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "05debc04038961337b694414b80afd58c9192a325b8e07e72331d6b505d388ac"
  },
  "id": "9AyVRp0MXaQM4LHF",
  "tags": [
    {
      "createdAt": "2025-08-11T11:03:12.782Z",
      "updatedAt": "2025-08-11T11:03:12.782Z",
      "id": "fxnG4IaUnFjYhCf6",
      "name": "whatsapp-ai"
    },
    {
      "createdAt": "2025-08-11T11:03:12.819Z",
      "updatedAt": "2025-08-11T11:03:12.819Z",
      "id": "u6GyntPyho5GOGBq",
      "name": "wasender-api"
    }
  ]
}