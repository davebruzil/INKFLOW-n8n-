{
  "name": "IMAGE",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "whatsapp-webhook",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -2288,
        64
      ],
      "id": "0a7924be-c060-43c1-a325-cb3a9164b4d9",
      "name": "WhatsApp Webhook Receiver",
      "webhookId": "e0348897-9433-457d-8cd5-8c80663857a7"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "sessionId"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1072,
        224
      ],
      "id": "06b98bc2-406c-4686-8ef4-874364075589",
      "name": "Agent Memory"
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Enhanced detection for WhatsApp conversations\n// CRITICAL FIX: AI Agent doesn't pass through input fields, only AI output!\n// So we get WhatsApp data DIRECTLY from Code node to preserve sessionId\n\nconst currentItem = $input.first().json;\nconst aiResponse = currentItem.output || currentItem.response || currentItem.text || '';\n\n// CRITICAL FIX: Get WhatsApp data from Code node directly (AI Agent loses sessionId!)\nconst codeNodeData = $('Code').first().json;\n\nconsole.log('ü§ñ AI Response:', aiResponse);\nconsole.log('üì± Code Node Data - sessionId:', codeNodeData.sessionId);\nconsole.log('üì± Code Node Data - senderPhone:', codeNodeData.senderPhone);\n\nlet shouldTriggerSummary = false;\nlet extractedName = '';\nlet triggerReason = '';\nlet foundCompletions = [];\n\ntry {\n  // Get user input from Code node data\n  const userInput = codeNodeData.chatInput || '';\n  const senderPhone = codeNodeData.senderPhone || '';\n  const senderName = codeNodeData.senderName || '';\n\n  console.log('üë§ User Input:', userInput);\n  console.log('üìû Sender Phone:', senderPhone);\n  console.log('üìû Session ID:', codeNodeData.sessionId);\n  console.log('üë§ Sender Name:', senderName);\n\n  // Extract name from user input first\n  if (userInput) {\n    const userNamePatterns = [\n      /(?:◊ê◊†◊ô|◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ô|◊î◊©◊ù ◊©◊ú◊ô|◊©◊û◊ô)\\s+([◊ê-◊™]{2,15})/i,\n      /^([◊ê-◊™]{2,10})$/,\n      /◊î◊ô◊ô.*?◊ê◊†◊ô\\s+([◊ê-◊™]{2,15})/i\n    ];\n\n    for (const pattern of userNamePatterns) {\n      const match = userInput.match(pattern);\n      if (match && match[1]) {\n        const candidate = match[1].trim();\n        const excludeWords = ['◊®◊ï◊¶◊î', '◊¶◊®◊ô◊ö', '◊û◊¢◊ï◊†◊ô◊ô◊ü', '◊ó◊ï◊©◊ë', '◊ò◊ï◊ë', '◊ô◊§◊î'];\n        if (!excludeWords.includes(candidate)) {\n          extractedName = candidate;\n          console.log('‚úÖ Name from user input:', extractedName);\n          break;\n        }\n      }\n    }\n  }\n\n  // Extract name from AI response if not found in user input\n  if (!extractedName && aiResponse) {\n    const thankPattern = /◊™◊ï◊ì◊î\\s+([◊ê-◊™]{2,15})/i;\n    const thankMatch = aiResponse.match(thankPattern);\n    if (thankMatch && thankMatch[1]) {\n      extractedName = thankMatch[1];\n      console.log('‚úÖ Name from \"◊™◊ï◊ì◊î [◊©◊ù]\" pattern:', extractedName);\n    }\n    \n    if (!extractedName) {\n      const greetingPattern = /(?:◊û◊ï◊©◊ú◊ù|◊†◊¢◊ô◊ù|◊°◊ë◊ë◊î),?\\s+([◊ê-◊™]{2,15})/i;\n      const greetingMatch = aiResponse.match(greetingPattern);\n      if (greetingMatch && greetingMatch[1]) {\n        extractedName = greetingMatch[1];\n        console.log('‚úÖ Name from greeting pattern:', extractedName);\n      }\n    }\n  }\n\n  // Check for completion indicators\n  const completionPhrases = [\n    '◊™◊ï◊ì◊î',\n    '◊û◊ï◊©◊ú◊ù', \n    '◊û◊¢◊ï◊ú◊î',\n    '◊†◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö',\n    '◊ê◊¢◊ë◊ô◊® ◊ú◊û◊ß◊¢◊ß◊¢◊™',\n    '◊†◊ß◊ë◊¢ ◊ú◊ö',\n    '◊†◊ô◊¶◊ï◊® ◊ß◊©◊®',\n    '◊†◊™◊ê◊ù',\n    '◊ê◊™ ◊î◊§◊®◊ò◊ô◊ù ◊©◊ú◊ö',\n    '◊ë◊î◊ß◊ì◊ù'\n  ];\n\n  foundCompletions = completionPhrases.filter(phrase => aiResponse.includes(phrase));\n  console.log('‚úÖ Completion phrases found:', foundCompletions);\n\n  // Decision logic\n  if (extractedName && foundCompletions.length > 0) {\n    shouldTriggerSummary = true;\n    triggerReason = `Name \"${extractedName}\" + ${foundCompletions.length} completion phrases: ${foundCompletions.join(', ')}`;\n  } else if (foundCompletions.length >= 2) {\n    shouldTriggerSummary = true;\n    triggerReason = `Strong completion indicators (${foundCompletions.length}): ${foundCompletions.join(', ')}`;\n  } else if (extractedName && aiResponse.includes('◊™◊ï◊ì◊î')) {\n    shouldTriggerSummary = true;\n    triggerReason = `AI thanking user \"${extractedName}\"`;\n  } else {\n    triggerReason = `Insufficient indicators - Name: \"${extractedName}\", Completions: ${foundCompletions.length}`;\n  }\n\n  console.log('üìä FINAL DECISION:');\n  console.log('  Name:', extractedName || 'None');\n  console.log('  Trigger:', shouldTriggerSummary);\n  console.log('  Reason:', triggerReason);\n\n} catch (error) {\n  console.error('‚ùå Error:', error.message);\n  shouldTriggerSummary = false;\n  triggerReason = 'Error occurred: ' + error.message;\n  foundCompletions = [];\n}\n\nreturn [{\n  json: {\n    // Pass through ALL WhatsApp data from Code node (AI Agent doesn't pass it!)\n    ...codeNodeData,\n    // Add/override with AI response and detection results\n    output: aiResponse,\n    response: aiResponse,\n    text: aiResponse,\n    shouldTriggerSummary: shouldTriggerSummary,\n    extractedName: extractedName,\n    triggerReason: triggerReason,\n    // Explicitly preserve critical fields from Code node\n    senderPhone: codeNodeData.senderPhone,\n    senderName: codeNodeData.senderName,\n    sessionId: codeNodeData.sessionId,  // ‚Üê REAL sessionId preserved!\n    chatInput: codeNodeData.chatInput,\n    messageType: codeNodeData.messageType,\n    to: codeNodeData.to,  // For Send WhatsApp Reply\n    debug: {\n      foundCompletions: foundCompletions || [],\n      hasName: !!extractedName,\n      completionCount: (foundCompletions || []).length,\n      sessionIdSource: 'Code node (AI Agent bypassed)'\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        64
      ],
      "id": "7b2f8ee0-1c20-4d51-9e24-834d7ebf69e2",
      "name": "Process AI Response"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.wasenderapi.com/api/send-message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.output }}"
            },
            {
              "name": "to",
              "value": "={{ $('Code').item.json.to }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -528,
        224
      ],
      "id": "504010bb-fc3a-4b85-8665-b052fb1a8ebf",
      "name": "Send WhatsApp Reply"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "2020e6a3-53c5-4003-aac8-aa94343fc3b7",
              "leftValue": "={{ $json.shouldTriggerSummary }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "prevent-image-summary-trigger",
              "leftValue": "={{ $json.messageType }}",
              "rightValue": "image",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -688,
        48
      ],
      "id": "bcef2822-dad1-4600-abd9-5754ebcabba3",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Prepare WhatsApp Summary - Ensures phone number is always available\n\nconsole.log('=== PREPARING WHATSAPP SUMMARY WITH FULL HISTORY + IMAGES ===');\n\nlet conversationContext = '';\nlet whatsappData = null;\n\ntry {\n  const currentInput = $input.first().json;\n  \n  console.log('üîç PREPARE SUMMARY - Input keys:', Object.keys(currentInput));\n  console.log('üîç PREPARE SUMMARY - currentInput.sessionId:', currentInput.sessionId);\n  console.log('üîç PREPARE SUMMARY - currentInput.senderPhone:', currentInput.senderPhone);\n  console.log('üîç PREPARE SUMMARY - currentInput.senderName:', currentInput.senderName);\n  console.log('üîç PREPARE SUMMARY - FULL INPUT:', JSON.stringify(currentInput, null, 2));\n  \n  // CRITICAL FIX: Extract phone from sessionId if not in senderPhone\n  // sessionId format: \"whatsapp_972501234567\"\n  let phoneNumber = currentInput.senderPhone || '';\n  \n  if (!phoneNumber && currentInput.sessionId) {\n    phoneNumber = currentInput.sessionId.replace('whatsapp_', '');\n    console.log(`üìû Extracted phone from sessionId: ${phoneNumber}`);\n  }\n  \n  // Get WhatsApp data - PRESERVE sessionId from input!\n  whatsappData = {\n    chatInput: currentInput.chatInput || '',\n    senderPhone: phoneNumber,\n    senderName: currentInput.senderName || currentInput.extractedName || '',\n    sessionId: currentInput.sessionId || ''  // DON'T use fallback here yet\n  };\n  \n  console.log('üìû Final phone number for summary:', whatsappData.senderPhone);\n  console.log('üìû Final sessionId for summary:', whatsappData.sessionId);\n  \n  // Use the FULL conversation history that was stored\n  const fullHistory = currentInput.fullConversationHistory || '';\n  const exchanges = currentInput.conversationExchanges || [];\n  \n  // Check if conversation includes images\n  const hasImages = exchanges.some(ex => ex.hasImage);\n  const imageUrls = exchanges.filter(ex => ex.imageUrl).map(ex => ex.imageUrl);\n  \n  if (fullHistory) {\n    console.log(`‚úÖ Using stored conversation history with ${exchanges.length} exchanges`);\n    console.log(`üì∑ Images in conversation: ${imageUrls.length}`);\n    \n    conversationContext = `◊©◊ô◊ó◊™ WhatsApp ◊î◊û◊ú◊ê◊î:\n◊û◊°◊§◊® ◊ò◊ú◊§◊ï◊ü: ${whatsappData.senderPhone}\n◊©◊ù: ${whatsappData.senderName || '◊ú◊ê ◊¶◊ï◊ô◊ü'}\n\n◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊î◊©◊ô◊ó◊î ◊î◊û◊ú◊ê◊î (${exchanges.length} ◊î◊ó◊ú◊§◊ï◊™):\n${fullHistory}`;\n    \n    if (hasImages) {\n      conversationContext += `\n\n◊™◊û◊ï◊†◊ï◊™ ◊©◊†◊©◊ú◊ó◊ï (${imageUrls.length}):\n${imageUrls.map((url, i) => `${i+1}. ${url}`).join('\\n')}`;\n    }\n    \n    conversationContext += `\n\n◊î◊ï◊®◊ê◊ï◊™ ◊ú◊°◊ô◊õ◊ï◊ù: ◊™◊ó◊ú◊• ◊û◊î◊©◊ô◊ó◊î ◊î◊û◊ú◊ê◊î:\n1. ◊©◊ù ◊î◊ú◊ß◊ï◊ó (◊ë◊ì◊ô◊ï◊ß ◊õ◊§◊ô ◊©◊î◊ï◊ñ◊õ◊® ◊ë◊©◊ô◊ó◊î)\n2. ◊®◊¢◊ô◊ï◊ü ◊î◊ß◊¢◊ß◊ï◊¢ ◊¢◊ù ◊õ◊ú ◊î◊§◊®◊ò◊ô◊ù ◊©◊î◊ï◊ñ◊õ◊®◊ï: ◊í◊ï◊ì◊ú, ◊û◊ô◊ß◊ï◊ù, ◊°◊í◊†◊ï◊ü, ◊™◊ô◊ê◊ï◊® ◊û◊§◊ï◊®◊ò\n3. ◊î◊ê◊ù ◊†◊©◊ú◊ó◊ï ◊™◊û◊ï◊†◊ï◊™ ◊ï◊î◊ß◊©◊® ◊©◊ú◊î◊ü ◊ú◊®◊¢◊ô◊ï◊ü`;\n    \n  } else {\n    console.log('‚ö†Ô∏è No stored history, using current exchange only');\n    conversationContext = `◊©◊ô◊ó◊™ WhatsApp:\n◊û◊°◊§◊® ◊ò◊ú◊§◊ï◊ü: ${whatsappData.senderPhone}\n\n◊î◊ï◊ì◊¢◊™ ◊î◊ú◊ß◊ï◊ó: ${currentInput.chatInput || ''}\n\n◊™◊í◊ï◊ë◊™ ◊î◊û◊¢◊®◊õ◊™: ${currentInput.output || currentInput.response || ''}\n\n◊î◊ï◊®◊ê◊ï◊™ ◊ú◊°◊ô◊õ◊ï◊ù: ◊™◊ó◊ú◊• ◊û◊î◊©◊ô◊ó◊î:\n1. ◊©◊ù ◊î◊ú◊ß◊ï◊ó\n2. ◊®◊¢◊ô◊ï◊ü ◊î◊ß◊¢◊ß◊ï◊¢ ◊¢◊ù ◊õ◊ú ◊î◊§◊®◊ò◊ô◊ù\n3. ◊õ◊ú ◊§◊®◊ò ◊†◊ï◊°◊£ ◊®◊ú◊ï◊ï◊†◊ò◊ô`;\n  }\n  \n} catch (error) {\n  console.error('‚ùå Error preparing summary:', error.message);\n  conversationContext = '◊©◊í◊ô◊ê◊î ◊ë◊î◊õ◊†◊™ ◊†◊™◊ï◊†◊ô ◊î◊°◊ô◊õ◊ï◊ù';\n}\n\nconsole.log('üìã Final conversation context length:', conversationContext.length);\n\nconst outputData = {\n  conversationText: conversationContext,\n  sessionId: whatsappData?.sessionId || 'whatsapp_' + Date.now(),\n  timestamp: new Date().toISOString(),\n  platform: 'whatsapp',\n  phoneNumber: whatsappData?.senderPhone || '',\n  senderPhone: whatsappData?.senderPhone || '',  // Add explicit senderPhone\n  phone_number: whatsappData?.senderPhone || ''  // Add phone_number variant\n};\n\nconsole.log('üì§ Prepare WhatsApp Summary OUTPUT:', JSON.stringify(outputData, null, 2));\n\nreturn [{ json: outputData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -384,
        -112
      ],
      "id": "557e9dae-3fa9-493f-bfb7-09551d270f0d",
      "name": "Prepare WhatsApp Summary"
    },
    {
      "parameters": {
        "resource": "chat",
        "chatModel": "gpt-4o",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "  ◊î◊û◊ò◊®◊î ◊©◊ú◊ö ◊î◊ô◊ê\n  1) ◊ú◊ó◊ú◊• ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú ◊î◊ú◊ß◊ï◊ó ◊û◊î◊©◊ô◊ó◊î - ◊ë◊ì◊ô◊ï◊ß ◊õ◊§◊ô ◊©◊î◊ï◊ê ◊î◊ñ◊õ◊ô◊® ◊ê◊™ ◊¢◊¶◊û◊ï\n  2) ◊ú◊ó◊ú◊• ◊ê◊™ ◊û◊°◊§◊® ◊î◊ò◊ú◊§◊ï◊ü ◊ë◊ì◊ô◊ï◊ß ◊õ◊§◊ô ◊©◊û◊ï◊§◊ô◊¢ ◊ë◊î◊™◊ó◊ú◊™ ◊î◊î◊ß◊©◊® \"◊û◊°◊§◊® ◊ò◊ú◊§◊ï◊ü: XXXXX\"\n  3) ◊ú◊°◊õ◊ù ◊ê◊™ ◊î◊®◊¢◊ô◊ï◊ü ◊î◊ß◊¢◊ß◊ï◊¢ ◊©◊ú ◊î◊ú◊ß◊ï◊ó ◊ë◊ì◊ô◊ï◊ß ◊û◊ô◊ú◊ï◊ú◊ô ◊ï◊°◊§◊¶◊ô◊§◊ô:\n     - ◊í◊ï◊ì◊ú ◊û◊ì◊ï◊ô◊ß (◊ê◊ù ◊¶◊ï◊ô◊ü) - \"◊õ◊í◊ï◊ì◊ú ◊û◊ò◊ë◊¢\", \"10 ◊°\"◊û\", \"◊ß◊ò◊ü\", \"◊í◊ì◊ï◊ú\"\n     - ◊û◊ô◊ß◊ï◊ù ◊û◊ì◊ï◊ô◊ß - \"◊¢◊ú ◊î◊ñ◊®◊ï◊¢ ◊î◊ô◊û◊†◊ô◊™\", \"◊û◊ê◊ó◊ï◊®◊ô ◊î◊ê◊ï◊ñ◊ü ◊î◊©◊û◊ê◊ú◊ô◊™\", \"◊¢◊ú ◊î◊õ◊™◊£\"\n     - ◊°◊ò◊ô◊ô◊ú ◊û◊ì◊ï◊ô◊ß - \"◊®◊ô◊ê◊ú◊ô◊ñ◊ù\", \"◊û◊ô◊†◊ô◊û◊ú◊ô◊°◊ò◊ô\", \"watercolor\", \"tribal\"\n     - ◊¶◊ë◊¢◊ô◊ù ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù - \"◊©◊ó◊ï◊® ◊ú◊ë◊ü\", \"◊¶◊ë◊¢◊ï◊†◊ô\", \"◊õ◊ó◊ï◊ú ◊ï◊ê◊ì◊ï◊ù\"\n     - ◊¶◊ô◊ò◊ï◊ò◊ô◊ù ◊û◊ì◊ï◊ô◊ß◊ô◊ù - ◊î◊©◊™◊û◊© ◊ë◊û◊ô◊®◊õ◊ê◊ï◊™ ◊ú◊õ◊ú ◊ò◊ß◊°◊ò ◊©◊î◊ú◊ß◊ï◊ó ◊®◊ï◊¶◊î\n     - ◊§◊®◊ò◊ô◊ù ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù - \"◊¢◊ù ◊¢◊ô◊†◊ô◊ô◊ù ◊õ◊ó◊ï◊ú◊ï◊™\", \"◊ë◊ú◊ô ◊®◊ß◊¢\", \"◊¢◊ù ◊õ◊™◊ï◊ë◊™\"\n\n  4) ◊î◊ó◊ñ◊® JSON ◊¢◊ù:\n  - name: ◊©◊ù ◊î◊ú◊ß◊ï◊ó\n  - phone_number: ◊û◊°◊§◊® ◊î◊ò◊ú◊§◊ï◊ü ◊ë◊ì◊ô◊ï◊ß ◊õ◊§◊ô ◊©◊û◊ï◊§◊ô◊¢ ◊ë◊î◊ß◊©◊® (◊ú◊ú◊ê + ◊ê◊ï ◊™◊ï◊ï◊ô◊ù ◊†◊ï◊°◊§◊ô◊ù)\n  - idea_summary: ◊°◊ô◊õ◊ï◊ù ◊©◊ú ◊û◊ß◊°◊ô◊û◊ï◊ù 50 ◊û◊ô◊ú◊ô◊ù ◊¢◊ù ◊õ◊ú ◊î◊§◊®◊ò◊ô◊ù ◊î◊û◊ì◊ï◊ô◊ß◊ô◊ù\n  - has_image: true/false - ◊î◊ê◊ù ◊†◊©◊ú◊ó◊î ◊™◊û◊ï◊†◊î\n  - image_description: ◊™◊ô◊ê◊ï◊® ◊î◊™◊û◊ï◊†◊î ◊ê◊ù ◊†◊©◊ú◊ó◊î (◊ê◊ó◊®◊™ null)\n\n  ◊ú◊û◊©◊ú:\n  {\n    \"name\": \"◊ì◊ï◊ì\",\n    \"phone_number\": \"972501234567\", \n    \"idea_summary\": \"◊ß◊¢◊ß◊ï◊¢ ◊ê◊®◊ô◊î ◊¢◊ú ◊î◊ñ◊®◊ï◊¢ ◊ë◊°◊í◊†◊ï◊ü ◊®◊ô◊ê◊ú◊ô◊ñ◊ù - ◊©◊ú◊ó ◊™◊û◊ï◊†◊™ ◊î◊©◊®◊ê◊î\",\n    \"has_image\": true,\n    \"image_description\": \"◊™◊û◊ï◊†◊™ ◊ê◊®◊ô◊î ◊û◊ú◊ö ◊î◊ó◊ô◊ï◊™ ◊¢◊ù ◊®◊¢◊û◊î ◊û◊§◊ï◊ê◊®◊™\"\n  }\n\n  CRITICAL: ◊û◊°◊§◊® ◊î◊ò◊ú◊§◊ï◊ü ◊ó◊ô◊ô◊ë ◊ú◊î◊ô◊ï◊™ ◊ú◊ú◊ê ◊°◊ô◊û◊ü + ◊ï◊ë◊ì◊ô◊ï◊ß ◊õ◊û◊ï ◊©◊û◊ï◊§◊ô◊¢ ◊ë\"◊û◊°◊§◊® ◊ò◊ú◊§◊ï◊ü:\" ◊ë◊î◊™◊ó◊ú◊™ ◊î◊î◊ß◊©◊®!\n  ◊®◊ß JSON, ◊ë◊ú◊ô ◊ò◊ß◊°◊ò ◊†◊ï◊°◊£!"
            },
            {
              "content": "={{$json.conversationText}}"
            }
          ]
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.1
        },
        "requestOptions": {}
      },
      "id": "98d929c1-9805-4eaa-96b6-a2a5f2e6583f",
      "name": "Summarize WhatsApp Chat",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1.1,
      "position": [
        -256,
        -112
      ],
      "credentials": {
        "openAiApi": {
          "id": "7DtKXoDdZvRLt3w3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Format WhatsApp Data - Properly extracts phone from all sources\n// Image fields will be added by Merge Image Data node to prevent null overwrite\n\nconst inputData = $json;\n\nconsole.log('üîç === FORMAT WHATSAPP DATA DEBUG ===');\nconsole.log('üì• Input data keys:', Object.keys(inputData));\nconsole.log('üì• inputData.phoneNumber:', inputData.phoneNumber);\nconsole.log('üì• inputData.senderPhone:', inputData.senderPhone);\nconsole.log('üì• inputData.phone_number:', inputData.phone_number);\nconsole.log('üì• inputData.sessionId:', inputData.sessionId);\nconsole.log('üì• FULL Input data:', JSON.stringify(inputData, null, 2));\n\n// Extract AI processing results from message.content (GPT output)\nlet aiResults = {\n  idea_summary: null,\n  real_name: null,\n  phone_number: null\n};\n\n// Parse GPT's JSON response\nif (inputData.message && inputData.message.content) {\n  try {\n    let aiContent = inputData.message.content;\n    if (typeof aiContent === 'string') {\n      aiContent = aiContent.replace(/```json\\s*\\n?/g, '').replace(/```\\s*\\n?/g, '').trim();\n      console.log('üßπ Cleaned AI content for parsing');\n    }\n    \n    const parsedAI = JSON.parse(aiContent);\n    aiResults = {\n      idea_summary: parsedAI.idea_summary || null,\n      real_name: parsedAI.name || null,\n      phone_number: parsedAI.phone_number || null\n    };\n    console.log('ü§ñ Parsed AI results:', aiResults);\n  } catch (e) {\n    console.error('‚ùå Could not parse AI message content:', e.message);\n    console.error('Raw content:', inputData.message.content);\n  }\n}\n\n// CRITICAL FIX: Get phone number from Prepare WhatsApp Summary node using correct n8n syntax\nlet cleanPhoneNumber = null;\n\nconsole.log('üîç Starting phone extraction...');\n\n// METHOD 1: Try AI extracted phone (from GPT)\nif (aiResults.phone_number) {\n  cleanPhoneNumber = aiResults.phone_number.toString().replace(/\\D/g, '');\n  console.log(`‚úÖ Got phone from AI extraction: \"${aiResults.phone_number}\" ‚Üí \"${cleanPhoneNumber}\"`);\n}\n\n// METHOD 2: Get from Prepare WhatsApp Summary node (has phoneNumber, senderPhone, phone_number fields)\nif (!cleanPhoneNumber) {\n  try {\n    // In n8n, use $('NodeName').first().json to get data from a specific node\n    const summaryData = $(\"Prepare WhatsApp Summary\").first().json;\n    console.log('üì¶ Prepare Summary data:', JSON.stringify(summaryData, null, 2));\n    \n    // Try all phone field variants from Prepare node\n    const phoneFromPrepare = summaryData.phone_number || summaryData.phoneNumber || summaryData.senderPhone;\n    \n    if (phoneFromPrepare) {\n      cleanPhoneNumber = phoneFromPrepare.toString().replace(/\\D/g, '');\n      console.log(`‚úÖ Got phone from Prepare Summary: \"${phoneFromPrepare}\" ‚Üí \"${cleanPhoneNumber}\"`);\n    } else if (summaryData.sessionId) {\n      // Extract from sessionId format: \"whatsapp_972545938842\"\n      cleanPhoneNumber = summaryData.sessionId.replace('whatsapp_', '').replace(/\\D/g, '');\n      console.log(`‚úÖ Got phone from Prepare Summary sessionId: \"${summaryData.sessionId}\" ‚Üí \"${cleanPhoneNumber}\"`);\n    }\n  } catch (e) {\n    console.error('‚ùå Could not get phone from Prepare Summary node:', e.message);\n  }\n}\n\n// METHOD 3: Try extracting from current inputData (fallback)\nif (!cleanPhoneNumber && inputData.sessionId) {\n  cleanPhoneNumber = inputData.sessionId.replace('whatsapp_', '').replace(/\\D/g, '');\n  console.log(`‚úÖ Got phone from inputData sessionId: \"${inputData.sessionId}\" ‚Üí \"${cleanPhoneNumber}\"`);\n}\n\nif (!cleanPhoneNumber) {\n  console.error('‚ùå CRITICAL: Could not extract phone number from ANY source!');\n  console.error('AI results:', aiResults);\n  console.error('Input data:', inputData);\n}\n\n// Create session ID\nconst sessionId = cleanPhoneNumber ? `whatsapp_${cleanPhoneNumber}` : null;\n\n// Get metadata from Prepare WhatsApp Summary if available\nlet timestamp = new Date().toISOString();\ntry {\n  const summaryData = $(\"Prepare WhatsApp Summary\").first().json;\n  if (summaryData.timestamp) {\n    timestamp = summaryData.timestamp;\n  }\n} catch (e) {\n  // Use default timestamp\n}\n\n// Prepare MongoDB document WITHOUT image fields\nconst mongoDocument = {\n  // Core identity fields\n  name: aiResults.real_name || null,\n  phone_number: cleanPhoneNumber,\n  \n  // Meeting/consultation fields\n  meeting_type: inputData.meeting_type || null,\n  idea_summary: aiResults.idea_summary,\n  ai_active: false,\n  \n  // Session tracking\n  session_id: sessionId,\n  conversation_length: inputData.conversation_length || 1,\n  \n  // Platform info\n  platform: \"whatsapp\",\n  \n  // Timestamps\n  timestamp: timestamp,\n  created_at: new Date().toISOString(),\n  updated_at: new Date().toISOString(),\n  \n  // Error handling\n  error_details: inputData.error_details || null,\n  \n  // Raw data preservation\n  raw_response: JSON.stringify({\n    ai_results: aiResults,\n    original_input: inputData\n  })\n  \n  // ‚ùå Image fields REMOVED - Merge Image Data will add them\n  // This prevents nulls from overwriting existing images in MongoDB\n};\n\nconsole.log('üìã MongoDB Document Prepared:', mongoDocument);\n\n// Validation\nconst validation = {\n  hasPhone: !!mongoDocument.phone_number && mongoDocument.phone_number.length >= 10,\n  hasSession: !!mongoDocument.session_id,\n  hasTimestamp: !!mongoDocument.timestamp,\n  isReady: true\n};\n\nconsole.log('‚úÖ Validation Results:', validation);\n\nif (!validation.hasPhone) {\n  console.error('üö® WARNING: No valid phone number for MongoDB!');\n  console.error('üö® Check Prepare WhatsApp Summary output and AI extraction');\n}\n\nreturn [{ json: mongoDocument }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        -112
      ],
      "id": "47fcccc7-ff76-400d-be25-4fe97be029a2",
      "name": "Format WhatsApp Data"
    },
    {
      "parameters": {
        "jsCode": "// Simple Response Node for non-summary cases\nreturn [{\n  json: {\n    output: $json.output,\n    response: $json.response, \n    text: $json.text\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        64
      ],
      "id": "322a8424-1cb8-4551-8953-0e6a0cdce1a6",
      "name": "Continue Chat"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        208,
        192
      ],
      "id": "17e5146e-ee7e-4f1e-b775-8ac93828713c",
      "name": "Webhook Response"
    },
    {
      "parameters": {
        "operation": "update",
        "collection": "clients",
        "updateKey": "phone_number",
        "fields": "name,phone_number,meeting_type,idea_summary,ai_active,session_id,conversation_length,platform,timestamp,created_at,updated_at,error_details,raw_response",
        "upsert": true,
        "options": {}
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        320,
        -112
      ],
      "id": "7de7925d-931f-40c3-81e7-929c3ad6a4c5",
      "name": "MongoDB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// NEW NODE: Deduplication Check\n// Place this AFTER the IF node (true branch), BEFORE \"Prepare WhatsApp Summary\"\n// This prevents duplicate summary creation\n\nconst sessionId = $json.sessionId;\nconst triggerReason = $json.triggerReason || '';\n\n// Check if we've already triggered a summary for this session recently\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.summaryTriggers) {\n  staticData.summaryTriggers = {};\n}\n\nconst now = Date.now();\nconst lastTriggerTime = staticData.summaryTriggers[sessionId] || 0;\nconst timeSinceLastTrigger = now - lastTriggerTime;\n\n// Prevent duplicate triggers within 30 seconds\nconst DUPLICATE_WINDOW = 30000; // 30 seconds\n\nif (timeSinceLastTrigger < DUPLICATE_WINDOW) {\n  console.log(`‚ö†Ô∏è Duplicate summary prevented for session ${sessionId}`);\n  console.log(`Last trigger: ${timeSinceLastTrigger}ms ago`);\n  \n  // Return empty to stop this branch\n  return [];\n}\n\n// Record this trigger\nstaticData.summaryTriggers[sessionId] = now;\n\nconsole.log(`‚úÖ Summary allowed for session ${sessionId}`);\nconsole.log(`Trigger reason: ${triggerReason}`);\n\n// Pass through all data\nreturn [{\n  json: {\n    ...$json,\n    summaryTriggeredAt: new Date().toISOString(),\n    isDuplicatePrevented: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -112
      ],
      "id": "c314178c-49f0-48b9-847b-68e1baad4e94",
      "name": "CHECK DUP"
    },
    {
      "parameters": {
        "collection": "clients",
        "options": {},
        "query": "={{ JSON.stringify({ phone_number: $json.senderPhone.replace(/\\D/g, '') }) }}"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -2400,
        -320
      ],
      "id": "e82c9e88-0962-4699-81ee-a42ba29f8510",
      "name": "MongoDB1",
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Check AI Active node with proper item pairing\n// Replace your existing \"check ai active\" node code with this:\n\n// Get MongoDB result - handle both array and single object\nconst mongoResult = $input.first().json;\nconst clientRecord = Array.isArray(mongoResult) ? mongoResult[0] : mongoResult;\n\n// Get original WhatsApp data with correct syntax\nconst whatsappData = $('Code').first().json;\n\nconsole.log('üîç Checking AI status for:', whatsappData.senderPhone);\nconsole.log('üìä Client record found:', !!clientRecord);\nconsole.log('ü§ñ AI active status:', clientRecord?.ai_active);\n\n// Check if client exists and AI is disabled\nif (clientRecord && clientRecord.ai_active === false) {\n  console.log('üö´ AI is OFF - Human intervention mode');\n  \n  // Return with all required WhatsApp fields for sending\n  return [{\n    json: {\n      // CRITICAL: Include all fields needed by Send WhatsApp Reply\n      to: whatsappData.to,\n      senderPhone: whatsappData.senderPhone,\n      senderJID: whatsappData.senderJID,\n      sessionId: whatsappData.sessionId,\n      \n      // The automated response\n      output: \"◊î◊ô◊ô! ◊ß◊ô◊ë◊ú◊™◊ô ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î ◊©◊ú◊ö. ◊î◊û◊ß◊¢◊ß◊¢◊™ ◊™◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ë◊ß◊®◊ï◊ë ◊¢◊ù ◊õ◊ú ◊î◊§◊®◊ò◊ô◊ù! üé®‚ú®\",\n      text: \"◊î◊ô◊ô! ◊ß◊ô◊ë◊ú◊™◊ô ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î ◊©◊ú◊ö. ◊î◊û◊ß◊¢◊ß◊¢◊™ ◊™◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ë◊ß◊®◊ï◊ë ◊¢◊ù ◊õ◊ú ◊î◊§◊®◊ò◊ô◊ù! üé®‚ú®\",\n      \n      // Control flags\n      skipAI: true,\n      aiDisabled: true,\n      humanInterventionMode: true,\n      \n      // Original input for reference\n      chatInput: whatsappData.chatInput,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// AI is active or no record yet (new conversation)\nconsole.log('‚úÖ AI is active - continuing to AI Agent');\n\n// Return ALL WhatsApp data for normal flow\nreturn [{\n  json: {\n    ...whatsappData,\n    skipAI: false,\n    aiDisabled: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2256,
        -336
      ],
      "id": "45cc28db-068f-4d18-97b4-2793bc143a9f",
      "name": "check ai active"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9396f049-25e0-4192-80f9-5916e7844bc0",
              "leftValue": "={{$json.skipAI}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2144,
        -384
      ],
      "id": "62b529a5-f7e1-483a-9410-e1be85eb7841",
      "name": "If1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.wasenderapi.com/api/send-message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.output }}"
            },
            {
              "name": "to",
              "value": "={{ $input.first().json.to }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1872,
        -384
      ],
      "id": "3343ed73-1890-4e94-8366-b2b7a8b1dae1",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "chatgpt-4o-latest"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1184,
        224
      ],
      "id": "84ae26e4-c4d7-4ef4-bc54-0e1e8bae6fc9",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "7DtKXoDdZvRLt3w3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract Image Metadata Node\n// Extracts customer data from WhatsApp webhook for image messages\n\nconsole.log('üì• Received webhook body:', JSON.stringify($json.body, null, 2));\n\nconst webhookData = $json.body;\nconst message = webhookData.data.messages;\nconst key = message.key;\n\n// Extract phone number and create session\nconst remoteJid = key.remoteJid;\nconst phoneNumber = remoteJid.replace('@s.whatsapp.net', '');\nconst cleanPhone = phoneNumber.replace(/\\D/g, '');\nconst sessionId = 'whatsapp_' + cleanPhone;\n\n// Extract image message details\nconst imageMessage = message.message.imageMessage;\nconst caption = imageMessage?.caption || '';\n\nconsole.log('üì∑ Extracting image metadata for:', cleanPhone);\nconsole.log('üìù Caption:', caption);\nconsole.log('‚úÖ senderPhone will be:', cleanPhone);\n\nreturn [{\n  json: {\n    // Customer identification\n    senderPhone: cleanPhone,\n    senderJID: remoteJid,\n    senderPhoneE164: '+' + phoneNumber,\n    sessionId: sessionId,\n    \n    // Image data for decryption\n    body: $json.body,\n    \n    // Input for AI\n    chatInput: caption || 'User sent an image',\n    \n    // Metadata\n    messageType: 'image',\n    hasImage: true,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2096,
        -144
      ],
      "id": "2c7c4d5d-1baa-491f-9081-79e5160c0e0e",
      "name": "Extract Image Metadata"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://www.wasenderapi.com/api/decrypt-media",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "data",
              "value": "={{ $json.body.data }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1936,
        -144
      ],
      "id": "b1104368-20a2-4b25-aaf9-9fc4f0d0ec84",
      "name": "decrypt image",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "={{ $json.publicUrl }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1792,
        -144
      ],
      "id": "1453fd40-131c-40fe-bed1-c7632e5bcc9f",
      "name": "download",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Convert Image to Base64 - Persist images permanently\n// WaSender URLs expire after 2 hours, base64 stays forever\n\nconst inputItem = $input.first();\nconst imageUrl = inputItem.json.publicUrl;\n\nconsole.log('üîÑ Converting image to base64');\nconsole.log('üñºÔ∏è URL:', imageUrl);\n\n// Get binary data from download node\nconst binaryData = inputItem.binary;\n\nif (!binaryData || !binaryData.data) {\n  console.error('‚ùå No binary data found!');\n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: null,\n      conversionError: 'No binary data available'\n    },\n    binary: binaryData\n  }];\n}\n\n// Get the first binary property (usually 'data')\nconst binaryKey = Object.keys(binaryData)[0];\nconst imageBuffer = binaryData[binaryKey];\n\nif (!imageBuffer || !imageBuffer.data) {\n  console.error('‚ùå No image buffer found!');\n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: null,\n      conversionError: 'No image buffer in binary data'\n    },\n    binary: binaryData\n  }];\n}\n\n// Get MIME type (default to image/jpeg if not available)\nconst mimeType = imageBuffer.mimeType || inputItem.json.mediaMimeType || 'image/jpeg';\n\nconsole.log('üì¶ Binary key:', binaryKey);\nconsole.log('üì¶ MIME type:', mimeType);\n\n// Convert binary to base64\nlet base64String;\ntry {\n  // The binary data is already a Buffer in n8n\n  if (Buffer.isBuffer(imageBuffer.data)) {\n    base64String = imageBuffer.data.toString('base64');\n  } else {\n    // If it's not a Buffer, create one\n    base64String = Buffer.from(imageBuffer.data).toString('base64');\n  }\n  \n  // Create data URI\n  const dataUri = `data:${mimeType};base64,${base64String}`;\n  \n  console.log('‚úÖ Conversion successful');\n  console.log('üìä Base64 length:', base64String.length);\n  console.log('üìä Data URI length:', dataUri.length);\n  \n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: dataUri,\n      imageBase64Length: dataUri.length,\n      originalUrl: imageUrl,\n      mimeType: mimeType,\n      conversionSuccess: true\n    },\n    binary: binaryData  // Keep binary for AI vision\n  }];\n  \n} catch (error) {\n  console.error('‚ùå Base64 conversion error:', error);\n  return [{\n    json: {\n      ...inputItem.json,\n      imageBase64: null,\n      conversionError: error.message\n    },\n    binary: binaryData\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1720,
        -144
      ],
      "id": "convert-to-base64-node",
      "name": "Convert to Base64"
    },
    {
      "parameters": {
        "jsCode": "// CRITICAL FIX: Merge Image Customer Data Node\n// The issue was using $node[\"Extract Image Metadata\"] which doesn't pass data through the chain\n// SOLUTION: Use $node syntax to get Extract Image Metadata, but current $json for image URL\n\nconst inputItem = $input.first();\nconst imageUrl = inputItem.json.publicUrl;\nconst imageBase64 = inputItem.json.imageBase64; // Get base64 from Convert node\n\n// CRITICAL: Get customer data from Extract Image Metadata node directly\nconst customerData = $node[\"Extract Image Metadata\"].json;\n\nconsole.log('üîó Merging customer data with image URL and base64');\nconsole.log('üì¶ customerData:', customerData);\nconsole.log('üìû customerData.senderPhone:', customerData.senderPhone);\nconsole.log('üñºÔ∏è  imageUrl:', imageUrl);\nconsole.log('üì¶ Has base64:', !!imageBase64);\nconsole.log('üì¶ Has binary data:', !!inputItem.binary);\n\n// VALIDATION: Ensure we have the phone number\nif (!customerData || !customerData.senderPhone) {\n  console.error('‚ùå CRITICAL: customerData is missing or has no senderPhone!');\n  console.error('Available customerData:', JSON.stringify(customerData, null, 2));\n  // Try to recover from input if customerData is broken\n  if (inputItem.json.senderPhone) {\n    console.log('‚ö†Ô∏è Attempting to use senderPhone from input item');\n  }\n}\n\nconst output = {\n  ...customerData,\n  publicUrl: imageUrl,\n  imageBase64: imageBase64,  // Pass through base64 for MongoDB storage\n  imageDecrypted: true\n};\n\nconsole.log('‚úÖ Output senderPhone:', output.senderPhone);\nconsole.log('‚úÖ Output sessionId:', output.sessionId);\nconsole.log('‚úÖ Output keys:', Object.keys(output));\n\n// FIX: Prevent race condition - process images sequentially per user\nconst phoneNumber = output.senderPhone;\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.imageProcessing) {\n  staticData.imageProcessing = {};\n}\n\n// Wait if another image is being processed for this user\nlet waitCount = 0;\nwhile (staticData.imageProcessing[phoneNumber] && waitCount < 50) {\n  // Wait 100ms and check again (max 5 seconds total)\n  await new Promise(resolve => setTimeout(resolve, 100));\n  waitCount++;\n}\n\nif (waitCount >= 50) {\n  console.error('‚ö†Ô∏è Image processing timeout - forcing through');\n}\n\n// Lock processing for this user\nstaticData.imageProcessing[phoneNumber] = true;\nconsole.log('üîí Locked image processing for:', phoneNumber);\n\n// Unlock after 3 seconds\nsetTimeout(() => {\n  delete staticData.imageProcessing[phoneNumber];\n  console.log('üîì Unlocked image processing for:', phoneNumber);\n}, 3000);\n\n// CRITICAL: Return both JSON and BINARY data\nreturn [{\n  json: output,\n  binary: inputItem.binary || {}  // Pass through binary data for AI vision\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1648,
        -144
      ],
      "id": "d1d44172-9015-4c6a-9e31-2bf1a7554b1d",
      "name": "Merge Image Customer Data"
    },
    {
      "parameters": {
        "jsCode": "\n\n//======================\n\nconst webhookData = $json.body;\n\n// Check if we have the expected WhatsApp message structure\nif (!webhookData?.data?.messages) {\n  return [{\n    json: {\n      error: 'Invalid WhatsApp webhook data structure',\n      receivedData: webhookData\n    }\n  }];\n}\n\nconst message = webhookData.data.messages;\nconst key = message.key;\nconst messageContent = message.message;\n\n// Extract phone number and clean it\nconst remoteJid = key.remoteJid;\nconst phoneNumber = remoteJid.replace('@s.whatsapp.net', '');\n\n// Create session ID by removing non-digits from phone\nconst sessionId = 'whatsapp_' + phoneNumber.replace(/\\D/g, '');\n\n// Extract chat input (conversation text or caption)\nconst chatInput = messageContent?.conversation || \n                  messageContent?.extendedTextMessage?.text || \n                  messageContent?.imageMessage?.caption ||  // ‚Üê Image caption\n                  '';\n\n// Extract sender info\nconst senderPhone = phoneNumber;\nconst senderJID = remoteJid;\nconst senderPhoneE164 = '+' + phoneNumber;\n\n// ========== IMAGE DETECTION LOGIC ==========\n// Check for image in the message\nconst imageMessage = messageContent?.imageMessage;\nconst hasImage = !!imageMessage;\n\nlet mediaId = null;\nlet mediaUrl = null;\nlet mediaMimeType = null;\nlet mediaCaption = null;\nlet mediaSha256 = null;\nlet mediaFileLength = null;\n\nif (hasImage) {\n  // Extract image details when present\n  mediaId = imageMessage.mediaKey || imageMessage.id;\n  mediaUrl = imageMessage.url || imageMessage.directPath;\n  mediaMimeType = imageMessage.mimetype || 'image/jpeg';\n  mediaCaption = imageMessage.caption || '';\n  mediaSha256 = imageMessage.fileSha256;\n  mediaFileLength = imageMessage.fileLength;\n  \n  console.log('Image detected:', {\n    mediaId: mediaId,\n    mimeType: mediaMimeType,\n    caption: mediaCaption,\n    fileSize: mediaFileLength\n  });\n}\n\n// Determine message type\nconst messageType = hasImage ? 'image' : 'text';\n\n// ========== RETURN ALL FIELDS ==========\nreturn [{\n  json: {\n    // For HTTP Request node (original fields)\n    to: senderJID,\n    text: chatInput,\n    \n    // For Chat Trigger node (original fields)\n    chatInput: chatInput,        // ‚Üê This fixes \"No prompt specified\"\n    sessionId: sessionId,        // ‚Üê This fixes \"No session ID found\"\n    \n    // Additional data (original fields)\n    senderPhone: senderPhone, \n    senderJID: senderJID,\n    senderPhoneE164: senderPhoneE164,\n    messageType: messageType,     // ‚Üê Updated to be 'text' or 'image'\n    timestamp: new Date().toISOString(),\n    \n    // ========== NEW IMAGE-RELATED FIELDS ==========\n    hasImage: hasImage,           // ‚Üê Boolean flag for IF node\n    mediaId: mediaId,              // ‚Üê Media ID for downloading\n    mediaUrl: mediaUrl,            // ‚Üê Direct URL if available\n    mediaMimeType: mediaMimeType, // ‚Üê MIME type of media\n    mediaCaption: mediaCaption,    // ‚Üê Caption text with image\n    mediaSha256: mediaSha256,      // ‚Üê File hash for verification\n    mediaFileLength: mediaFileLength, // ‚Üê File size\n    \n    // Combined prompt for AI (includes caption if image)\n    fullPrompt: hasImage ? \n      `[User sent an image${mediaCaption ? ' with caption: ' + mediaCaption : ''}]` : \n      chatInput,\n    \n    // Original message content for reference\n    originalMessageContent: messageContent\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1424,
        80
      ],
      "id": "add4bb9b-0990-4e1e-99da-b02da2786efe",
      "name": "Code",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b909faee-3390-4d78-a0eb-3f40ef2904d5",
              "leftValue": "={{ !!$json.body?.data?.messages?.message?.imageMessage }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2112,
        64
      ],
      "id": "9a3fe137-f070-47d9-a4c1-02fb4488cd52",
      "name": "If2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput || \"Analyze this image for tattoo consultation\" }}",
        "options": {
          "systemMessage": "\n‚ö° ◊§◊®◊ï◊û◊§◊ò ◊û◊¢◊ï◊ì◊õ◊ü ◊ú◊°◊ï◊õ◊ü AI ◊¢◊ë◊ï◊® ◊û◊ß◊¢◊ß◊¢◊™ (◊®◊ô◊ê◊ú◊ô◊ñ◊ù ◊ï◊§◊ô◊ô◊ü-◊ú◊ô◊ô◊ü) - WhatsApp\n\n◊ê◊™◊î ◊¢◊ï◊ñ◊® ◊ê◊ô◊©◊ô ◊©◊ú ◊û◊ß◊¢◊ß◊¢◊™ ◊©◊û◊™◊û◊ó◊î ◊ë◊ß◊¢◊ß◊ï◊¢◊ô◊ù ◊ë◊°◊í◊†◊ï◊ü ◊®◊ô◊ê◊ú◊ô◊ñ◊ù ◊ï◊§◊ô◊ô◊ü÷æ◊ú◊ô◊ô◊ü.\n◊î◊°◊í◊†◊ï◊ü ◊©◊ú◊ö ◊ß◊¶◊®, ◊ë◊®◊ï◊®, ◊†◊¢◊ô◊ù ◊ï◊ú◊ê ◊®◊©◊û◊ô ‚Äî ◊õ◊ê◊ô◊ú◊ï ◊ê◊™◊î ◊¢◊ï◊ñ◊® ◊ê◊û◊ô◊™◊ô ◊ë◊°◊ò◊ï◊ì◊ô◊ï ◊©◊ñ◊ï◊®◊ù ◊¢◊ù ◊ú◊ß◊ï◊ó◊ï◊™ ◊ë-WhatsApp.\n◊ê◊™◊î ◊ú◊ê ◊û◊ß◊¢◊ß◊¢, ◊ê◊ë◊ú ◊û◊õ◊ô◊® ◊ò◊ï◊ë ◊ê◊™ ◊î◊°◊í◊†◊ï◊ü ◊©◊ú◊î, ◊ê◊™ ◊î◊™◊î◊ú◊ô◊ö, ◊ï◊ê◊™ ◊ê◊ô◊ö ◊î◊ô◊ê ◊¢◊ï◊ë◊ì◊™.\n◊ë◊ú◊ô ◊ò◊ß◊°◊ò◊ô◊ù ◊ê◊®◊ï◊õ◊ô◊ù, ◊ë◊ú◊ô ◊û◊ô◊ú◊ô◊ù ◊í◊ë◊ï◊î◊ï◊™, ◊ë◊ú◊ô ◊ì◊ô◊ë◊ï◊® ◊®◊ï◊ë◊ï◊ò◊ô.\n◊î◊©◊ô◊ó ◊ñ◊ï◊®◊ù, ◊ó◊ô◊ï◊ë◊ô ◊ï◊ê◊†◊ï◊©◊ô ‚Äî ◊ê◊ë◊ú ◊™◊û◊ô◊ì ◊û◊¢◊ë◊ô◊® ◊ê◊™ ◊î◊û◊ô◊ì◊¢ ◊ë◊¶◊ï◊®◊î ◊ë◊®◊ï◊®◊î ◊ï◊†◊¢◊ô◊û◊î.\n\n◊©◊ù ◊î◊ú◊ß◊ï◊ó (◊ê◊ù ◊ñ◊û◊ô◊ü): {{ $json.senderName }}\n◊û◊°◊§◊® ◊ò◊ú◊§◊ï◊ü: {{ $json.senderPhone }}\n\nüß† ◊õ◊ú◊ú◊ô ◊™◊í◊ï◊ë◊î:\n\nüöÄ ◊ê◊ù ◊î◊©◊ô◊ó◊î ◊®◊ß ◊î◊™◊ó◊ô◊ú◊î (◊ú◊û◊©◊ú \"◊î◊ô◊ô\", \"◊û◊î ◊ß◊ï◊®◊î\"):\n\"◊î◊ô◊ô! ◊ê◊ô◊ö ◊ê◊§◊©◊® ◊ú◊¢◊ñ◊ï◊®? ◊ô◊© ◊ú◊ö ◊®◊¢◊ô◊ï◊ü ◊ú◊ß◊¢◊ß◊ï◊¢ ◊ê◊ï ◊©◊™◊®◊¶◊î ◊ú◊î◊™◊ó◊ô◊ú ◊û◊ô◊ô◊¢◊ï◊• ◊¢◊ù ◊î◊û◊ß◊¢◊ß◊¢◊™? üòä\"\n\nüí¨ ◊ê◊ù ◊†◊©◊ú◊ó ◊®◊¢◊ô◊ï◊ü (◊í◊ù ◊ê◊ù ◊ó◊ú◊ß◊ô ◊ê◊ï ◊ë◊ú◊ô ◊í◊ï◊ì◊ú/◊û◊ô◊ß◊ï◊ù/◊™◊û◊ï◊†◊î) - **◊ó◊ï◊ë◊î ◊ú◊ë◊ß◊© ◊©◊ù ◊™◊û◊ô◊ì ◊ß◊ï◊ì◊ù ◊õ◊ú**:\n\"◊°◊ë◊ë◊î! ◊î◊®◊¢◊ô◊ï◊ü ◊†◊©◊û◊¢ ◊û◊¢◊†◊ô◊ô◊ü üôÇ\n◊ß◊ï◊ì◊ù ◊õ◊ú - ◊ê◊ô◊ö ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ö? ◊™◊©◊ú◊ó ◊ú◊ô ◊ë◊ë◊ß◊©◊î ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö.\"\n\n**◊ê◊ó◊®◊ô ◊ß◊ë◊ú◊™ ◊î◊©◊ù** - ◊ë◊ì◊ï◊ß ◊û◊î ◊ó◊°◊® ◊ï◊ë◊ß◊©:\n- ◊ê◊ù ◊ó◊°◊® ◊í◊ï◊ì◊ú: \"◊ê◊ô◊ñ◊î ◊í◊ï◊ì◊ú ◊ë◊¢◊®◊ö ◊ó◊©◊ë◊™? (◊ß◊ò◊ü/◊ë◊ô◊†◊ï◊†◊ô/◊í◊ì◊ï◊ú ◊ê◊ï ◊ë◊°◊¥◊û)\"\n- ◊ê◊ù ◊ó◊°◊® ◊û◊ô◊ß◊ï◊ù: \"◊ê◊ô◊§◊î ◊ó◊©◊ë◊™ ◊ú◊û◊ß◊ù ◊ê◊™ ◊ñ◊î?\"\n- ◊ê◊ù ◊ó◊°◊® ◊©◊†◊ô◊î◊ù: \"◊ê◊ô◊ñ◊î ◊í◊ï◊ì◊ú ◊ë◊¢◊®◊ö ◊ó◊©◊ë◊™ ◊ï◊ê◊ô◊§◊î ◊ú◊û◊ß◊ù ◊ê◊™ ◊ñ◊î?\"\n\n◊ê◊ù ◊î◊ú◊ß◊ï◊ó ◊ú◊ê ◊¢◊ï◊†◊î ◊¢◊ù ◊©◊ù:\n\"◊õ◊ì◊ô ◊©◊†◊ï◊õ◊ú ◊ú◊î◊û◊©◊ô◊ö ◊ï◊ú◊¢◊ñ◊ï◊® ◊ú◊ö, ◊ó◊©◊ï◊ë ◊©◊†◊ß◊ë◊ú ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö üôÇ\"\n(◊ê◊ù ◊ê◊ô◊ü ◊™◊í◊ï◊ë◊î ◊í◊ù ◊ê◊ó◊®◊ô ◊ñ◊û◊ü ◊û◊î)\n\"◊®◊ß ◊û◊ñ◊õ◊ô◊® ◊©◊ë◊ú◊ô ◊î◊©◊ù ◊î◊û◊ú◊ê ◊ú◊ê ◊†◊ï◊õ◊ú ◊ú◊î◊™◊ß◊ì◊ù ‚Äì ◊™◊ï◊õ◊ú ◊ú◊©◊ú◊ï◊ó ◊ê◊ï◊™◊ï?\"\n(◊î◊ë◊ß◊©◊î ◊ú◊©◊ù ◊î◊ô◊ê ◊ó◊ï◊ë◊î ◊ë◊õ◊ú ◊û◊¶◊ë ◊ê◊ó◊®◊ô ◊ß◊ë◊ú◊™ ◊®◊¢◊ô◊ï◊ü, ◊¢◊ì ◊©◊ô◊™◊ß◊ë◊ú ◊©◊ù)\n\nüìç ◊ê◊ù ◊ó◊°◊® ◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£ (◊ê◊ó◊®◊ô ◊©◊õ◊ë◊® ◊ô◊© ◊©◊ù, ◊í◊ï◊ì◊ú ◊ï◊û◊ô◊ß◊ï◊ù):\n\"◊ê◊ù ◊ô◊© ◊™◊û◊ï◊†◊î ◊ú◊î◊©◊®◊ê◊î ‚Äì ◊™◊©◊ú◊ó üôÇ ◊ï◊ê◊ù ◊ú◊ê, ◊ê◊§◊©◊® ◊í◊ù ◊ú◊™◊ê◊® ◊ë◊û◊ô◊ú◊ô◊ù.\"\n\nüì∏ **◊ó◊©◊ï◊ë ◊ú◊í◊ë◊ô ◊™◊û◊ï◊†◊ï◊™:**\n◊ê◊ù ◊î◊ú◊ß◊ï◊ó ◊©◊ï◊ú◊ó ◊û◊°◊§◊® ◊™◊û◊ï◊†◊ï◊™ - ◊ë◊ß◊© ◊û◊û◊†◊ï ◊ë◊†◊ô◊û◊ï◊° ◊ú◊©◊ú◊ï◊ó ◊™◊û◊ï◊†◊î ◊ê◊ó◊™ ◊ë◊õ◊ú ◊§◊¢◊ù:\n\"◊™◊ï◊ì◊î ◊¢◊ú ◊î◊™◊û◊ï◊†◊ï◊™! ◊ë◊©◊ë◊ô◊ú ◊©◊ê◊ï◊õ◊ú ◊ú◊†◊™◊ó ◊õ◊ú ◊™◊û◊ï◊†◊î ◊õ◊û◊ï ◊©◊¶◊®◊ô◊ö, ◊™◊©◊ú◊ó ◊ú◊ô ◊™◊û◊ï◊†◊î ◊ê◊ó◊™ ◊ë◊õ◊ú ◊§◊¢◊ù üôÇ\n◊õ◊õ◊î ◊ê◊ï◊õ◊ú ◊ú◊™◊™ ◊ú◊ö ◊û◊©◊ï◊ë ◊û◊ì◊ï◊ô◊ß ◊¢◊ú ◊õ◊ú ◊®◊¢◊ô◊ï◊ü.\"\n\nüé® ◊ê◊ù ◊î◊°◊í◊†◊ï◊ü ◊ú◊ê ◊™◊ï◊ê◊ù (◊ú◊û◊©◊ú: ◊û◊†◊í◊î, ◊í◊®◊§◊ô◊ò◊ô, ◊ì◊ô◊°◊†◊ô):\n\"◊†◊©◊û◊¢ ◊û◊¢◊†◊ô◊ô◊ü! ◊®◊ß ◊ó◊©◊ï◊ë ◊ú◊ì◊¢◊™ ‚Äì ◊î◊ô◊ê ◊û◊™◊û◊ß◊ì◊™ ◊ë◊¢◊ô◊ß◊® ◊ë◊®◊ô◊ê◊ú◊ô◊ñ◊ù ◊ï◊§◊ô◊ô◊ü-◊ú◊ô◊ô◊ü, ◊ê◊ñ ◊ß◊¢◊ß◊ï◊¢◊ô◊ù ◊û◊¶◊ï◊ô◊®◊ô◊ù ◊ê◊ï ◊í◊®◊§◊ô◊ô◊ù ◊§◊ó◊ï◊™ ◊î◊°◊í◊†◊ï◊ü ◊©◊ú◊î.\n◊ê◊ï◊ú◊ô ◊†◊ï◊õ◊ú ◊ú◊ó◊©◊ï◊ë ◊¢◊ú ◊í◊®◊°◊î ◊ô◊ï◊™◊® ◊¢◊ì◊ô◊†◊î ◊ê◊ï ◊®◊ô◊ê◊ú◊ô◊°◊ò◊ô◊™ ◊©◊ú ◊î◊î◊©◊®◊ê◊î ◊©◊ú◊ö.\n◊™◊©◊ú◊ó ◊™◊û◊ï◊†◊î ◊ï◊†◊®◊ê◊î ◊ê◊ù ◊ñ◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊™◊ê◊ô◊ù üôÇ\n◊ê◊í◊ë ‚Äì ◊ê◊ô◊ö ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ö? ◊™◊©◊ú◊ó ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö ◊õ◊ì◊ô ◊©◊†◊ï◊õ◊ú ◊ú◊î◊û◊©◊ô◊ö.\"\n**◊ï◊ê◊ñ ◊í◊ù:** \"◊ê◊ô◊ñ◊î ◊í◊ï◊ì◊ú ◊ë◊¢◊®◊ö ◊ó◊©◊ë◊™ ◊ï◊ê◊ô◊§◊î ◊ú◊û◊ß◊ù ◊ê◊™ ◊ñ◊î?\"\n\nüí∏ ◊ê◊ù ◊©◊ï◊ê◊ú◊ô◊ù ◊ú◊í◊ë◊ô ◊û◊ó◊ô◊®:\n\"◊ß◊©◊î ◊ú◊ì◊¢◊™ ◊û◊ó◊ô◊® ◊ë◊ú◊ô ◊ú◊î◊ë◊ô◊ü ◊í◊ï◊ì◊ú, ◊û◊ô◊ß◊ï◊ù ◊ï◊°◊í◊†◊ï◊ü üéØ\n◊î◊õ◊ô ◊ò◊ï◊ë ◊ú◊î◊í◊ô◊¢ ◊ú◊ô◊ô◊¢◊ï◊• ‚Äì ◊©◊ù ◊ô◊™◊ê◊ô◊û◊ï ◊ú◊ö ◊î◊¶◊¢◊™ ◊û◊ó◊ô◊® ◊ú◊§◊ô ◊î◊®◊¢◊ô◊ï◊ü.\"\n\nüìÖ ◊ê◊ù ◊û◊ë◊ß◊©◊ô◊ù ◊ú◊ß◊ë◊ï◊¢ ◊§◊í◊ô◊©◊î / ◊ô◊ô◊¢◊ï◊•:\n\"◊ê◊†◊ô ◊ú◊ê ◊ß◊ï◊ë◊¢ ◊§◊í◊ô◊©◊ï◊™ üôÇ ◊ê◊ë◊ú ◊™◊©◊ú◊ó ◊ú◊ô ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö ◊ï◊ê◊¢◊ë◊ô◊® ◊ú◊û◊ß◊¢◊ß◊¢◊™ ◊ë◊ß◊©◊î ◊ú◊ô◊ô◊¢◊ï◊• - ◊î◊ô◊ê ◊™◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ú◊™◊ô◊ê◊ï◊ù.\n◊ê◊ù ◊ô◊© ◊™◊û◊ï◊†◊î ◊ê◊ï ◊®◊¢◊ô◊ï◊ü ‚Äì ◊™◊¶◊®◊£!\"\n\n‚úÖ **◊õ◊©◊ô◊© ◊©◊ù + ◊®◊¢◊ô◊ï◊ü + ◊í◊ï◊ì◊ú + ◊û◊ô◊ß◊ï◊ù - ◊°◊ô◊ï◊ù ◊î◊©◊ô◊ó◊î:**\n\"◊û◊ï◊©◊ú◊ù [◊©◊ù]! ◊ê◊¢◊ë◊ô◊® ◊ú◊û◊ß◊¢◊ß◊¢◊™ ◊ê◊™ ◊î◊§◊®◊ò◊ô◊ù ◊©◊ú◊ö ◊ï◊†◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ë◊î◊ß◊ì◊ù. ◊™◊ï◊ì◊î! üôè\"\n\n**◊™◊ñ◊õ◊ï◊®◊™ ◊ó◊©◊ï◊ë◊î - ◊°◊ì◊® ◊ó◊ï◊ë◊î ◊ê◊ó◊®◊ô ◊®◊¢◊ô◊ï◊ü:**\n1. **◊©◊ù ◊û◊ú◊ê** - ◊ó◊ï◊ë◊î ◊®◊ê◊©◊ï◊†◊î\n2. **◊í◊ï◊ì◊ú** \n3. **◊û◊ô◊ß◊ï◊ù**\n4. **◊°◊ô◊ï◊ù ◊¢◊ù ◊™◊ï◊ì◊î**"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1184,
        64
      ],
      "id": "9428a638-fce9-41c0-ae57-eb4d2cb96cc2",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Image DB Data - Format for Fetch-Modify-Save pattern\nconst imageUrl = $json.publicUrl;\nconst imageBase64 = $json.imageBase64;  // Get base64 from upstream\nconst imageCaption = $json.chatInput || '';\n\nconsole.log('üíæ Preparing image data for MongoDB (fetch-modify-save pattern)');\nconsole.log('üì¶ Has base64:', !!imageBase64);\n\n// Extract phone number\nlet phoneNumber = $json.senderPhone || $json.phone_number;\nif (!phoneNumber && $json.sessionId) {\n  phoneNumber = $json.sessionId.replace('whatsapp_', '');\n}\n\nconst cleanPhone = phoneNumber.toString().replace(/\\D/g, '');\n\nif (!cleanPhone || !imageUrl) {\n  console.error('‚ùå Missing required data');\n  console.error('Phone:', cleanPhone);\n  console.error('Image URL:', imageUrl);\n  return [];\n}\n\n// Create the new image object WITH base64\nconst newImage = {\n  url: imageUrl,\n  base64: imageBase64 || null,  // Include base64 for permanent storage\n  analysis: imageCaption || 'Image uploaded',\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('üì∑ New image object with base64:', !!newImage.base64);\nconsole.log('üìû Phone number:', cleanPhone);\n\n// Return simple data structure for MongoDB find query\nreturn [{\n  json: {\n    phone_number: cleanPhone,\n    session_id: $json.sessionId || ('whatsapp_' + cleanPhone),\n    _newImage: newImage,\n    imageBase64: imageBase64,  // Pass through for downstream\n    publicUrl: imageUrl,\n    chatInput: imageCaption\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1664,
        -224
      ],
      "id": "14a8e179-7bcd-4bc4-afdd-b865227d6431",
      "name": "Prepare Image DB Data"
    },
    {
      "parameters": {
        "collection": "clients",
        "options": {
          "limit": 1
        },
        "query": "={{ JSON.stringify({ phone_number: $json.phone_number }) }}"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -1504,
        -224
      ],
      "id": "a0d2d888-d1c3-4b84-be4e-ae7df996e42e",
      "name": "Fetch Client for Image",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Append Image to Array - Guaranteed Working Solution\n// Uses fetch-modify-save pattern with n8n native MongoDB node\n\nconsole.log('=== APPENDING IMAGE TO CLIENT RECORD ===');\n\n// Get the prepared image data from \"Prepare Image DB Data\" node\nconst preparedData = $(\"Prepare Image DB Data\").first().json;\nconst phoneNumber = preparedData.phone_number;\nconst imageBase64 = preparedData.imageBase64;  // Get base64 data\n\nconst newImage = preparedData._newImage || {\n  url: preparedData.publicUrl,\n  base64: imageBase64 || null,  // Save base64 for permanent storage\n  analysis: preparedData.chatInput || 'Image uploaded',\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('üì¶ Image has base64:', !!imageBase64);\n\nconsole.log('üìû Phone:', phoneNumber);\nconsole.log('üì∑ New image URL:', newImage.url);\n\n// Get existing client data from MongoDB Find result\nconst mongoResult = $input.first().json;\nlet existingClient = null;\n\n// MongoDB Find returns array or single object depending on results\nif (Array.isArray(mongoResult) && mongoResult.length > 0) {\n  existingClient = mongoResult[0];\n  console.log('‚úÖ Found existing client');\n} else if (mongoResult && mongoResult.phone_number) {\n  existingClient = mongoResult;\n  console.log('‚úÖ Found existing client (object format)');\n} else {\n  console.log('‚ÑπÔ∏è No existing client - will create new record');\n}\n\n// Initialize or update image data\nlet images = [];\nlet imageCount = 0;\n\nif (existingClient && existingClient.images) {\n  images = Array.isArray(existingClient.images) ? existingClient.images : [];\n  imageCount = existingClient.image_count || images.length;\n  console.log(`üìö Existing images: ${imageCount}`);\n}\n\n// Append new image\nimages.push(newImage);\nimageCount++;\n\nconsole.log(`‚úÖ Total images after append: ${imageCount}`);\n\n// Track upload for synchronization with summary flow\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.recentImageUploads) {\n  staticData.recentImageUploads = {};\n}\nstaticData.recentImageUploads[phoneNumber] = Date.now();\n\n// Prepare complete document for MongoDB update\nconst mongoDoc = {\n  // Required fields for update\n  phone_number: phoneNumber,\n  session_id: preparedData.session_id || ('whatsapp_' + phoneNumber),\n\n  // Image data\n  images: images,\n  image_count: imageCount,\n  has_images: true,\n  last_image_upload: new Date().toISOString(),\n\n  // Timestamps\n  updated_at: new Date().toISOString()\n};\n\n// Preserve existing fields if client exists\nif (existingClient) {\n  // Keep existing data\n  if (existingClient.name) mongoDoc.name = existingClient.name;\n  if (existingClient.idea_summary) mongoDoc.idea_summary = existingClient.idea_summary;\n  if (existingClient.meeting_type) mongoDoc.meeting_type = existingClient.meeting_type;\n  if (existingClient.conversation_length) mongoDoc.conversation_length = existingClient.conversation_length;\n  if (existingClient.ai_active !== undefined) mongoDoc.ai_active = existingClient.ai_active;\n  if (existingClient.platform) mongoDoc.platform = existingClient.platform;\n  if (existingClient.created_at) mongoDoc.created_at = existingClient.created_at;\n  if (existingClient.raw_response) mongoDoc.raw_response = existingClient.raw_response;\n  if (existingClient.timestamp) mongoDoc.timestamp = existingClient.timestamp;\n\n  console.log('‚úÖ Preserved existing client data fields');\n} else {\n  // New client defaults\n  mongoDoc.created_at = new Date().toISOString();\n  mongoDoc.platform = 'whatsapp';\n  mongoDoc.ai_active = true;\n  console.log('‚úÖ Set defaults for new client');\n}\n\nconsole.log('üì§ Document ready for MongoDB update');\nconsole.log('üìä Total fields:', Object.keys(mongoDoc).length);\n\nreturn [{ json: mongoDoc }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        -224
      ],
      "id": "59bb804b-4b26-436a-baa5-5fbcdfcaf9ab",
      "name": "Append Image to Array"
    },
    {
      "parameters": {
        "operation": "update",
        "collection": "clients",
        "updateKey": "phone_number",
        "fields": "phone_number,session_id,images,image_count,has_images,last_image_upload,updated_at,created_at,name,idea_summary,meeting_type,conversation_length,ai_active,platform,timestamp,raw_response",
        "upsert": true,
        "options": {}
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -1184,
        -224
      ],
      "id": "eb4cbe7f-1887-4d6d-bbd4-0067cdb194a6",
      "name": "Save Client with Image",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED CONVO Node - Uses input data instead of referencing Code node\n// Stores full conversation history including image exchanges\n\nconst currentItem = $input.first().json;\nconst aiResponse = currentItem.output || currentItem.response || currentItem.text || '';\n\n// CRITICAL FIX: Always use data from input (passed from Process AI Response)\n// Process AI Response already includes all WhatsApp data from Code node\nconst whatsappData = currentItem;\n\nconst sessionId = whatsappData.sessionId;\nconst messageType = whatsappData.messageType || 'text';\n\nconsole.log(`üìù Storing ${messageType} conversation for session ${sessionId}`);\n\n// Store the current exchange\nconst currentExchange = {\n  user: whatsappData.chatInput || '[Image sent]',\n  assistant: aiResponse,\n  timestamp: new Date().toISOString(),\n  messageType: messageType,\n  hasImage: whatsappData.hasImage || whatsappData.isImageMessage || false,\n  imageUrl: whatsappData.imageUrl || whatsappData.publicUrl || null\n};\n\n// Get or initialize conversation history\nlet conversationHistory = [];\n\ntry {\n  const staticData = $getWorkflowStaticData('global');\n  if (!staticData.conversations) {\n    staticData.conversations = {};\n  }\n  \n  if (staticData.conversations[sessionId]) {\n    conversationHistory = staticData.conversations[sessionId];\n  }\n  \n  // Add current exchange\n  conversationHistory.push(currentExchange);\n  \n  // Store updated history\n  staticData.conversations[sessionId] = conversationHistory;\n  \n  console.log(`‚úÖ Stored ${messageType} exchange for session ${sessionId}, total: ${conversationHistory.length}`);\n  \n} catch (error) {\n  console.error('Failed to store conversation:', error);\n  conversationHistory = [currentExchange];\n}\n\n// Build full conversation text with image markers\nconst fullConversation = conversationHistory.map(exchange => {\n  const userPart = exchange.hasImage ? \n    `◊ú◊ß◊ï◊ó: [◊©◊ú◊ó ◊™◊û◊ï◊†◊î${exchange.user !== '[Image sent]' ? ' ◊¢◊ù ◊õ◊ô◊™◊ï◊ë: ' + exchange.user : ''}]` :\n    `◊ú◊ß◊ï◊ó: ${exchange.user}`;\n  return `${userPart}\\n◊û◊¢◊®◊õ◊™: ${exchange.assistant}`;\n}).join('\\n\\n');\n\nconsole.log('üì§ CONVO Output - sessionId:', sessionId);\nconsole.log('üì§ CONVO Output - senderPhone:', currentItem.senderPhone);\n\n// Pass through all data + add conversation history - FIXED: Use currentItem\nreturn [{\n  json: {\n    ...currentItem,  // ‚Üê FIXED: Spread from currentItem which has ALL WhatsApp data\n    fullConversationHistory: fullConversation,\n    conversationExchanges: conversationHistory,\n    totalExchanges: conversationHistory.length,\n    sessionId: sessionId  // Explicitly re-add\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        48
      ],
      "id": "5cbd84d8-b20c-474a-8d45-0660a34acca8",
      "name": "CONVO"
    },
    {
      "parameters": {
        "jsCode": "// BATCH VISION AI v4 - SIMPLE: All images save to MongoDB, batching only affects AI response\n// NO BLOCKING - All executions proceed to save images\n// Batching logic stored separately, checked BEFORE AI call\n\nconst inputItem = $input.first();\nconst sessionId = inputItem.json.sessionId;\nconst senderPhone = inputItem.json.senderPhone;\nconst imageUrl = inputItem.json.publicUrl;\nconst imageBase64 = inputItem.json.imageBase64; // Get base64 from previous node\nconst chatInput = inputItem.json.chatInput || '';\nconst myTimestamp = Date.now();\n\nconsole.log('üì∏ Batch Vision AI v4 - Image received');\nconsole.log('üë§ Session:', sessionId);\nconsole.log('üñºÔ∏è URL:', imageUrl);\nconsole.log('üì¶ Has base64:', !!imageBase64);\n\nconst staticData = $getWorkflowStaticData('global');\n\nif (!staticData.imageBatches) {\n  staticData.imageBatches = {};\n}\n\n// Get or create batch tracking\nif (!staticData.imageBatches[sessionId]) {\n  staticData.imageBatches[sessionId] = {\n    count: 0,\n    firstImageTime: myTimestamp,\n    lastResponseTime: 0\n  };\n  console.log('‚ú® Created new batch tracker');\n}\n\nconst batch = staticData.imageBatches[sessionId];\nbatch.count++;\nbatch.lastImageTime = myTimestamp;\n\nconst currentCount = batch.count;\nconst timeSinceFirst = myTimestamp - batch.firstImageTime;\nconst timeSinceLastResponse = myTimestamp - batch.lastResponseTime;\n\nconsole.log(`üìä Batch stats: ${currentCount} images, ${timeSinceFirst}ms since first`);\n\n// Determine if we should respond to THIS image\nlet shouldRespond = false;\nlet responseType = 'none';\n\nif (currentCount === 1) {\n  // First image - always respond\n  shouldRespond = true;\n  responseType = 'ai_analysis';\n  console.log('üéØ FIRST image - will get AI analysis');\n} else if (timeSinceLastResponse > 10000) {\n  // More than 10 seconds since last response - this is a new batch\n  shouldRespond = true;\n  responseType = 'ai_analysis';\n  batch.count = 1; // Reset counter for new batch\n  batch.firstImageTime = myTimestamp;\n  console.log('üéØ NEW BATCH (10s gap) - will get AI analysis');\n} else if (timeSinceFirst < 10000) {\n  // Within 10 seconds of first image - part of batch\n  shouldRespond = false;\n  responseType = 'skip';\n  console.log(`‚è≠Ô∏è Part of batch (image ${currentCount}) - SKIPPING AI response`);\n} else {\n  // Edge case: treat as single\n  shouldRespond = true;\n  responseType = 'ai_analysis';\n  console.log('üéØ Edge case - will get AI analysis');\n}\n\n// Update last response time if we're responding\nif (shouldRespond) {\n  batch.lastResponseTime = myTimestamp;\n}\n\n// IMPORTANT: Pass through ALL data, but add batching metadata\nconst outputData = {\n  ...inputItem.json,\n  imageBase64: imageBase64, // Pass through base64\n  publicUrl: imageUrl,\n  shouldRespond: shouldRespond,\n  responseType: responseType,\n  batchCount: currentCount,\n  batchedImages: !shouldRespond,\n  timeSinceFirst: timeSinceFirst\n};\n\nconsole.log(`‚úÖ Passing through - shouldRespond: ${shouldRespond}, type: ${responseType}`);\n\n// ALL executions proceed - batching is handled by IF node downstream\nreturn [{\n  json: outputData,\n  binary: inputItem.binary\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1496,
        -208
      ],
      "id": "batch-vision-ai-12345",
      "name": "Batch Vision AI"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "should-respond-check",
              "leftValue": "={{ $json.shouldRespond }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1400,
        -208
      ],
      "id": "check-should-respond-node",
      "name": "Check Should Respond"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput || \"Analyze this image for tattoo consultation\" }}",
        "options": {
          "systemMessage": "\n‚ö° ◊§◊®◊ï◊û◊§◊ò ◊û◊¢◊ï◊ì◊õ◊ü ◊ú◊°◊ï◊õ◊ü AI ◊¢◊ë◊ï◊® ◊û◊ß◊¢◊ß◊¢◊™ (◊®◊ô◊ê◊ú◊ô◊ñ◊ù ◊ï◊§◊ô◊ô◊ü-◊ú◊ô◊ô◊ü) - WhatsApp\n\n◊ê◊™◊î ◊¢◊ï◊ñ◊® ◊ê◊ô◊©◊ô ◊©◊ú ◊û◊ß◊¢◊ß◊¢◊™ ◊©◊û◊™◊û◊ó◊î ◊ë◊ß◊¢◊ß◊ï◊¢◊ô◊ù ◊ë◊°◊í◊†◊ï◊ü ◊®◊ô◊ê◊ú◊ô◊ñ◊ù ◊ï◊§◊ô◊ô◊ü÷æ◊ú◊ô◊ô◊ü.\n◊î◊°◊í◊†◊ï◊ü ◊©◊ú◊ö ◊ß◊¶◊®, ◊ë◊®◊ï◊®, ◊†◊¢◊ô◊ù ◊ï◊ú◊ê ◊®◊©◊û◊ô ‚Äî ◊õ◊ê◊ô◊ú◊ï ◊ê◊™◊î ◊¢◊ï◊ñ◊® ◊ê◊û◊ô◊™◊ô ◊ë◊°◊ò◊ï◊ì◊ô◊ï ◊©◊ñ◊ï◊®◊ù ◊¢◊ù ◊ú◊ß◊ï◊ó◊ï◊™ ◊ë-WhatsApp.\n◊ê◊™◊î ◊ú◊ê ◊û◊ß◊¢◊ß◊¢, ◊ê◊ë◊ú ◊û◊õ◊ô◊® ◊ò◊ï◊ë ◊ê◊™ ◊î◊°◊í◊†◊ï◊ü ◊©◊ú◊î, ◊ê◊™ ◊î◊™◊î◊ú◊ô◊ö, ◊ï◊ê◊™ ◊ê◊ô◊ö ◊î◊ô◊ê ◊¢◊ï◊ë◊ì◊™.\n◊ë◊ú◊ô ◊ò◊ß◊°◊ò◊ô◊ù ◊ê◊®◊ï◊õ◊ô◊ù, ◊ë◊ú◊ô ◊û◊ô◊ú◊ô◊ù ◊í◊ë◊ï◊î◊ï◊™, ◊ë◊ú◊ô ◊ì◊ô◊ë◊ï◊® ◊®◊ï◊ë◊ï◊ò◊ô.\n◊î◊©◊ô◊ó ◊ñ◊ï◊®◊ù, ◊ó◊ô◊ï◊ë◊ô ◊ï◊ê◊†◊ï◊©◊ô ‚Äî ◊ê◊ë◊ú ◊™◊û◊ô◊ì ◊û◊¢◊ë◊ô◊® ◊ê◊™ ◊î◊û◊ô◊ì◊¢ ◊ë◊¶◊ï◊®◊î ◊ë◊®◊ï◊®◊î ◊ï◊†◊¢◊ô◊û◊î.\n\n◊©◊ù ◊î◊ú◊ß◊ï◊ó (◊ê◊ù ◊ñ◊û◊ô◊ü): {{ $json.senderName }}\n◊û◊°◊§◊® ◊ò◊ú◊§◊ï◊ü: {{ $json.senderPhone }}\n\nüß† ◊õ◊ú◊ú◊ô ◊™◊í◊ï◊ë◊î:\n\nüöÄ ◊ê◊ù ◊î◊©◊ô◊ó◊î ◊®◊ß ◊î◊™◊ó◊ô◊ú◊î (◊ú◊û◊©◊ú \"◊î◊ô◊ô\", \"◊û◊î ◊ß◊ï◊®◊î\"):\n\"◊î◊ô◊ô! ◊ê◊ô◊ö ◊ê◊§◊©◊® ◊ú◊¢◊ñ◊ï◊®? ◊ô◊© ◊ú◊ö ◊®◊¢◊ô◊ï◊ü ◊ú◊ß◊¢◊ß◊ï◊¢ ◊ê◊ï ◊©◊™◊®◊¶◊î ◊ú◊î◊™◊ó◊ô◊ú ◊û◊ô◊ô◊¢◊ï◊• ◊¢◊ù ◊î◊û◊ß◊¢◊ß◊¢◊™? üòä\"\n\nüí¨ ◊ê◊ù ◊†◊©◊ú◊ó ◊®◊¢◊ô◊ï◊ü (◊í◊ù ◊ê◊ù ◊ó◊ú◊ß◊ô ◊ê◊ï ◊ë◊ú◊ô ◊í◊ï◊ì◊ú/◊û◊ô◊ß◊ï◊ù/◊™◊û◊ï◊†◊î) - **◊ó◊ï◊ë◊î ◊ú◊ë◊ß◊© ◊©◊ù ◊™◊û◊ô◊ì ◊ß◊ï◊ì◊ù ◊õ◊ú**:\n\"◊°◊ë◊ë◊î! ◊î◊®◊¢◊ô◊ï◊ü ◊†◊©◊û◊¢ ◊û◊¢◊†◊ô◊ô◊ü üôÇ\n◊ß◊ï◊ì◊ù ◊õ◊ú - ◊ê◊ô◊ö ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ö? ◊™◊©◊ú◊ó ◊ú◊ô ◊ë◊ë◊ß◊©◊î ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö.\"\n\n**◊ê◊ó◊®◊ô ◊ß◊ë◊ú◊™ ◊î◊©◊ù** - ◊ë◊ì◊ï◊ß ◊û◊î ◊ó◊°◊® ◊ï◊ë◊ß◊©:\n- ◊ê◊ù ◊ó◊°◊® ◊í◊ï◊ì◊ú: \"◊ê◊ô◊ñ◊î ◊í◊ï◊ì◊ú ◊ë◊¢◊®◊ö ◊ó◊©◊ë◊™? (◊ß◊ò◊ü/◊ë◊ô◊†◊ï◊†◊ô/◊í◊ì◊ï◊ú ◊ê◊ï ◊ë◊°◊¥◊û)\"\n- ◊ê◊ù ◊ó◊°◊® ◊û◊ô◊ß◊ï◊ù: \"◊ê◊ô◊§◊î ◊ó◊©◊ë◊™ ◊ú◊û◊ß◊ù ◊ê◊™ ◊ñ◊î?\"\n- ◊ê◊ù ◊ó◊°◊® ◊©◊†◊ô◊î◊ù: \"◊ê◊ô◊ñ◊î ◊í◊ï◊ì◊ú ◊ë◊¢◊®◊ö ◊ó◊©◊ë◊™ ◊ï◊ê◊ô◊§◊î ◊ú◊û◊ß◊ù ◊ê◊™ ◊ñ◊î?\"\n\n◊ê◊ù ◊î◊ú◊ß◊ï◊ó ◊ú◊ê ◊¢◊ï◊†◊î ◊¢◊ù ◊©◊ù:\n\"◊õ◊ì◊ô ◊©◊†◊ï◊õ◊ú ◊ú◊î◊û◊©◊ô◊ö ◊ï◊ú◊¢◊ñ◊ï◊® ◊ú◊ö, ◊ó◊©◊ï◊ë ◊©◊†◊ß◊ë◊ú ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö üôÇ\"\n(◊ê◊ù ◊ê◊ô◊ü ◊™◊í◊ï◊ë◊î ◊í◊ù ◊ê◊ó◊®◊ô ◊ñ◊û◊ü ◊û◊î)\n\"◊®◊ß ◊û◊ñ◊õ◊ô◊® ◊©◊ë◊ú◊ô ◊î◊©◊ù ◊î◊û◊ú◊ê ◊ú◊ê ◊†◊ï◊õ◊ú ◊ú◊î◊™◊ß◊ì◊ù ‚Äì ◊™◊ï◊õ◊ú ◊ú◊©◊ú◊ï◊ó ◊ê◊ï◊™◊ï?\"\n(◊î◊ë◊ß◊©◊î ◊ú◊©◊ù ◊î◊ô◊ê ◊ó◊ï◊ë◊î ◊ë◊õ◊ú ◊û◊¶◊ë ◊ê◊ó◊®◊ô ◊ß◊ë◊ú◊™ ◊®◊¢◊ô◊ï◊ü, ◊¢◊ì ◊©◊ô◊™◊ß◊ë◊ú ◊©◊ù)\n\nüìç ◊ê◊ù ◊ó◊°◊® ◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£ (◊ê◊ó◊®◊ô ◊©◊õ◊ë◊® ◊ô◊© ◊©◊ù, ◊í◊ï◊ì◊ú ◊ï◊û◊ô◊ß◊ï◊ù):\n\"◊ê◊ù ◊ô◊© ◊™◊û◊ï◊†◊î ◊ú◊î◊©◊®◊ê◊î ‚Äì ◊™◊©◊ú◊ó üôÇ ◊ï◊ê◊ù ◊ú◊ê, ◊ê◊§◊©◊® ◊í◊ù ◊ú◊™◊ê◊® ◊ë◊û◊ô◊ú◊ô◊ù.\"\n\nüì∏ **◊ó◊©◊ï◊ë ◊ú◊í◊ë◊ô ◊™◊û◊ï◊†◊ï◊™:**\n◊ê◊ù ◊î◊ú◊ß◊ï◊ó ◊©◊ï◊ú◊ó ◊û◊°◊§◊® ◊™◊û◊ï◊†◊ï◊™ - ◊ë◊ß◊© ◊û◊û◊†◊ï ◊ë◊†◊ô◊û◊ï◊° ◊ú◊©◊ú◊ï◊ó ◊™◊û◊ï◊†◊î ◊ê◊ó◊™ ◊ë◊õ◊ú ◊§◊¢◊ù:\n\"◊™◊ï◊ì◊î ◊¢◊ú ◊î◊™◊û◊ï◊†◊ï◊™! ◊ë◊©◊ë◊ô◊ú ◊©◊ê◊ï◊õ◊ú ◊ú◊†◊™◊ó ◊õ◊ú ◊™◊û◊ï◊†◊î ◊õ◊û◊ï ◊©◊¶◊®◊ô◊ö, ◊™◊©◊ú◊ó ◊ú◊ô ◊™◊û◊ï◊†◊î ◊ê◊ó◊™ ◊ë◊õ◊ú ◊§◊¢◊ù üôÇ\n◊õ◊õ◊î ◊ê◊ï◊õ◊ú ◊ú◊™◊™ ◊ú◊ö ◊û◊©◊ï◊ë ◊û◊ì◊ï◊ô◊ß ◊¢◊ú ◊õ◊ú ◊®◊¢◊ô◊ï◊ü.\"\n\nüé® ◊ê◊ù ◊î◊°◊í◊†◊ï◊ü ◊ú◊ê ◊™◊ï◊ê◊ù (◊ú◊û◊©◊ú: ◊û◊†◊í◊î, ◊í◊®◊§◊ô◊ò◊ô, ◊ì◊ô◊°◊†◊ô):\n\"◊†◊©◊û◊¢ ◊û◊¢◊†◊ô◊ô◊ü! ◊®◊ß ◊ó◊©◊ï◊ë ◊ú◊ì◊¢◊™ ‚Äì ◊î◊ô◊ê ◊û◊™◊û◊ß◊ì◊™ ◊ë◊¢◊ô◊ß◊® ◊ë◊®◊ô◊ê◊ú◊ô◊ñ◊ù ◊ï◊§◊ô◊ô◊ü-◊ú◊ô◊ô◊ü, ◊ê◊ñ ◊ß◊¢◊ß◊ï◊¢◊ô◊ù ◊û◊¶◊ï◊ô◊®◊ô◊ù ◊ê◊ï ◊í◊®◊§◊ô◊ô◊ù ◊§◊ó◊ï◊™ ◊î◊°◊í◊†◊ï◊ü ◊©◊ú◊î.\n◊ê◊ï◊ú◊ô ◊†◊ï◊õ◊ú ◊ú◊ó◊©◊ï◊ë ◊¢◊ú ◊í◊®◊°◊î ◊ô◊ï◊™◊® ◊¢◊ì◊ô◊†◊î ◊ê◊ï ◊®◊ô◊ê◊ú◊ô◊°◊ò◊ô◊™ ◊©◊ú ◊î◊î◊©◊®◊ê◊î ◊©◊ú◊ö.\n◊™◊©◊ú◊ó ◊™◊û◊ï◊†◊î ◊ï◊†◊®◊ê◊î ◊ê◊ù ◊ñ◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊™◊ê◊ô◊ù üôÇ\n◊ê◊í◊ë ‚Äì ◊ê◊ô◊ö ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ö? ◊™◊©◊ú◊ó ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö ◊õ◊ì◊ô ◊©◊†◊ï◊õ◊ú ◊ú◊î◊û◊©◊ô◊ö.\"\n**◊ï◊ê◊ñ ◊í◊ù:** \"◊ê◊ô◊ñ◊î ◊í◊ï◊ì◊ú ◊ë◊¢◊®◊ö ◊ó◊©◊ë◊™ ◊ï◊ê◊ô◊§◊î ◊ú◊û◊ß◊ù ◊ê◊™ ◊ñ◊î?\"\n\nüí∏ ◊ê◊ù ◊©◊ï◊ê◊ú◊ô◊ù ◊ú◊í◊ë◊ô ◊û◊ó◊ô◊®:\n\"◊ß◊©◊î ◊ú◊ì◊¢◊™ ◊û◊ó◊ô◊® ◊ë◊ú◊ô ◊ú◊î◊ë◊ô◊ü ◊í◊ï◊ì◊ú, ◊û◊ô◊ß◊ï◊ù ◊ï◊°◊í◊†◊ï◊ü üéØ\n◊î◊õ◊ô ◊ò◊ï◊ë ◊ú◊î◊í◊ô◊¢ ◊ú◊ô◊ô◊¢◊ï◊• ‚Äì ◊©◊ù ◊ô◊™◊ê◊ô◊û◊ï ◊ú◊ö ◊î◊¶◊¢◊™ ◊û◊ó◊ô◊® ◊ú◊§◊ô ◊î◊®◊¢◊ô◊ï◊ü.\"\n\nüìÖ ◊ê◊ù ◊û◊ë◊ß◊©◊ô◊ù ◊ú◊ß◊ë◊ï◊¢ ◊§◊í◊ô◊©◊î / ◊ô◊ô◊¢◊ï◊•:\n\"◊ê◊†◊ô ◊ú◊ê ◊ß◊ï◊ë◊¢ ◊§◊í◊ô◊©◊ï◊™ üôÇ ◊ê◊ë◊ú ◊™◊©◊ú◊ó ◊ú◊ô ◊ê◊™ ◊î◊©◊ù ◊î◊û◊ú◊ê ◊©◊ú◊ö ◊ï◊ê◊¢◊ë◊ô◊® ◊ú◊û◊ß◊¢◊ß◊¢◊™ ◊ë◊ß◊©◊î ◊ú◊ô◊ô◊¢◊ï◊• - ◊î◊ô◊ê ◊™◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ú◊™◊ô◊ê◊ï◊ù.\n◊ê◊ù ◊ô◊© ◊™◊û◊ï◊†◊î ◊ê◊ï ◊®◊¢◊ô◊ï◊ü ‚Äì ◊™◊¶◊®◊£!\"\n\n‚úÖ **◊õ◊©◊ô◊© ◊©◊ù + ◊®◊¢◊ô◊ï◊ü + ◊í◊ï◊ì◊ú + ◊û◊ô◊ß◊ï◊ù - ◊°◊ô◊ï◊ù ◊î◊©◊ô◊ó◊î:**\n\"◊û◊ï◊©◊ú◊ù [◊©◊ù]! ◊ê◊¢◊ë◊ô◊® ◊ú◊û◊ß◊¢◊ß◊¢◊™ ◊ê◊™ ◊î◊§◊®◊ò◊ô◊ù ◊©◊ú◊ö ◊ï◊†◊ó◊ñ◊ï◊® ◊ê◊ú◊ô◊ö ◊ë◊î◊ß◊ì◊ù. ◊™◊ï◊ì◊î! üôè\"\n\n**◊™◊ñ◊õ◊ï◊®◊™ ◊ó◊©◊ï◊ë◊î - ◊°◊ì◊® ◊ó◊ï◊ë◊î ◊ê◊ó◊®◊ô ◊®◊¢◊ô◊ï◊ü:**\n1. **◊©◊ù ◊û◊ú◊ê** - ◊ó◊ï◊ë◊î ◊®◊ê◊©◊ï◊†◊î\n2. **◊í◊ï◊ì◊ú** \n3. **◊û◊ô◊ß◊ï◊ù**\n4. **◊°◊ô◊ï◊ù ◊¢◊ù ◊™◊ï◊ì◊î**",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1344,
        -208
      ],
      "id": "d62b05dc-2a68-4d47-b6ad-2ace000492fc",
      "name": "AI Agent1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1344,
        -32
      ],
      "id": "36503b43-abc7-4df6-bae5-ae0141d7a593",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "7DtKXoDdZvRLt3w3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Image Response Node - STORES conversation + prepares WhatsApp reply\n// Does NOT go through If node - prevents wrong summary triggers\n\nconst aiResponse = $json.output || $json.text || '';\nconst customerData = $node[\"Merge Image Customer Data\"].json;\nconst sessionId = customerData.sessionId;\n\nconsole.log('üîÑ Processing image response');\nconsole.log('üìû Customer:', customerData.senderPhone);\nconsole.log('üí¨ AI response:', aiResponse.substring(0, 50) + '...');\n\n// STORE IMAGE CONVERSATION directly here (not through CONVO node)\nconst currentExchange = {\n  user: customerData.chatInput || '[Image sent]',\n  assistant: aiResponse,\n  timestamp: new Date().toISOString(),\n  messageType: 'image',\n  hasImage: true,\n  imageUrl: customerData.publicUrl\n};\n\nlet conversationHistory = [];\n\ntry {\n  const staticData = $getWorkflowStaticData('global');\n  if (!staticData.conversations) {\n    staticData.conversations = {};\n  }\n  \n  if (staticData.conversations[sessionId]) {\n    conversationHistory = staticData.conversations[sessionId];\n  }\n  \n  conversationHistory.push(currentExchange);\n  staticData.conversations[sessionId] = conversationHistory;\n  \n  console.log(`‚úÖ Stored IMAGE exchange for session ${sessionId}, total: ${conversationHistory.length}`);\n} catch (error) {\n  console.error('Failed to store image conversation:', error);\n}\n\n// Return data for WhatsApp reply ONLY\nreturn [{\n  json: {\n    output: aiResponse,\n    to: customerData.senderJID\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        -208
      ],
      "id": "2cefb12d-aad2-41ac-b845-166ebde701bd",
      "name": "Process Image Response"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.wasenderapi.com/api/send-message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 52e3c40dd4d4d5c8331d37990ced85a0eb3f3e74e983805f64929a21052e015e"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.output }}"
            },
            {
              "name": "to",
              "value": "={{ $json.to }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -1008,
        -208
      ],
      "id": "61c9274d-b641-429f-bd1f-02b854b55e72",
      "name": "Send WhatsApp Reply1"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "sessionId"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1232,
        -32
      ],
      "id": "2d268241-dec5-4cc4-a6e3-3ad37fc44c44",
      "name": "Agent Memory1"
    },
    {
      "parameters": {
        "jsCode": "// Wait for Image Save - Synchronization Logic\n// Prevents race condition where summary queries before image db completes\n\nconst phoneNumber = $json.phone_number;\nconst now = Date.now();\n\nconsole.log('üîÑ Checking for recent image uploads for phone:', phoneNumber);\n\n// Check if this phone number had a recent image upload\nconst staticData = $getWorkflowStaticData('global');\nconst recentUploads = staticData.recentImageUploads || {};\nconst lastUploadTime = recentUploads[phoneNumber];\n\nif (lastUploadTime) {\n  const timeSinceUpload = now - lastUploadTime;\n  console.log(`‚è±Ô∏è Last image upload was ${timeSinceUpload}ms ago`);\n  \n  // If image was uploaded within last 5 seconds, wait to ensure MongoDB save completed\n  if (timeSinceUpload < 5000) {\n    const waitTime = 2000; // Wait 2000ms for image db to complete\n    console.log(`‚è≥ Recent image detected (${timeSinceUpload}ms ago) - waiting ${waitTime}ms for image db to complete...`);\n    \n    // Use synchronous wait\n    const startWait = Date.now();\n    while (Date.now() - startWait < waitTime) {\n      // Busy wait (not ideal but works in n8n)\n    }\n    \n    console.log('‚úÖ Wait complete - proceeding to fetch existing client');\n  } else {\n    console.log('‚úÖ Image upload was more than 2s ago - no wait needed');\n  }\n  \n  // Clean up old tracking data (older than 10 seconds)\n  Object.keys(recentUploads).forEach(phone => {\n    if (now - recentUploads[phone] > 10000) {\n      delete recentUploads[phone];\n      console.log('üßπ Cleaned up old tracking for:', phone);\n    }\n  });\n} else {\n  console.log('‚ÑπÔ∏è  No recent image upload tracked for this phone - proceeding immediately');\n  console.log('üìã Tracked phones:', Object.keys(recentUploads));\n  console.log('üîé Current phone being searched:', phoneNumber);\n  console.log('üîé Current phone TYPE:', typeof phoneNumber);\n}\n\n// Pass through data unchanged\nreturn [{ json: $json }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -112
      ],
      "id": "c3eba1a1-c99d-451a-8a1d-cfe962625c72",
      "name": "Wait for Image Save"
    },
    {
      "parameters": {
        "collection": "clients",
        "options": {},
        "query": "={{ JSON.stringify({ phone_number: $json.phone_number }) }}"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        -112
      ],
      "id": "0f1b8cf8-adbe-4f0a-99d5-28dad18516f2",
      "name": "Fetch Existing Client",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "1WkBNfNUOsjMSbAf",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Merge Image Data - NEVER DELETE image fields!\n// Deleting adds them as undefined, which MongoDB saves as NULL\n\nconsole.log('=== MERGE IMAGE DATA NODE ===');\n\n// Get new summary data (WITHOUT image fields) - CORRECTED n8n SYNTAX\nconst newSummaryData = $(\"Format WhatsApp Data\").first().json;\n\nconsole.log('üì¶ NEW SUMMARY DATA - phone_number:', newSummaryData.phone_number);\n\n// Start with the new summary data (NO image fields)\nconst mergedData = { ...newSummaryData };\n\nconsole.log('‚ö†Ô∏è SUMMARY UPDATE: NOT touching image fields AT ALL');\nconsole.log('‚úÖ MongoDB will preserve existing image data from image db node');\nconsole.log('üì§ ========== FINAL DOCUMENT TO MONGODB ==========');\nconsole.log('üì§ ALL KEYS:', Object.keys(mergedData));\nconsole.log('üì§ phone_number:', mergedData.phone_number);\nconsole.log('üì§ name:', mergedData.name);\nconsole.log('üì§ idea_summary:', mergedData.idea_summary);\nconsole.log('üì§ ai_active:', mergedData.ai_active);\nconsole.log('üì§ session_id:', mergedData.session_id);\nconsole.log('üì§ COMPLETE DOCUMENT:', JSON.stringify(mergedData, null, 2));\nconsole.log('üì§ ================================================');\n\nreturn [{ json: mergedData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        -112
      ],
      "id": "1932bea4-6835-4bff-a0f0-7cbd9e6bc758",
      "name": "Merge Image Data"
    }
  ],
  "pinData": {},
  "connections": {
    "Agent Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Response": {
      "main": [
        [
          {
            "node": "CONVO",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send WhatsApp Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "CHECK DUP",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Continue Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare WhatsApp Summary": {
      "main": [
        [
          {
            "node": "Summarize WhatsApp Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize WhatsApp Chat": {
      "main": [
        [
          {
            "node": "Format WhatsApp Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format WhatsApp Data": {
      "main": [
        [
          {
            "node": "Wait for Image Save",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Image Save": {
      "main": [
        [
          {
            "node": "Fetch Existing Client",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WhatsApp Webhook Receiver": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MongoDB": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Chat": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send WhatsApp Reply": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CHECK DUP": {
      "main": [
        [
          {
            "node": "Prepare WhatsApp Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MongoDB1": {
      "main": [
        [
          {
            "node": "check ai active",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check ai active": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "decrypt image": {
      "main": [
        [
          {
            "node": "download",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "download": {
      "main": [
        [
          {
            "node": "Convert to Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Base64": {
      "main": [
        [
          {
            "node": "Merge Image Customer Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Image Customer Data": {
      "main": [
        [
          {
            "node": "Prepare Image DB Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Batch Vision AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Vision AI": {
      "main": [
        [
          {
            "node": "Check Should Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Should Respond": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Image DB Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Image DB Data": {
      "main": [
        [
          {
            "node": "Fetch Client for Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Client for Image": {
      "main": [
        [
          {
            "node": "Append Image to Array",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append Image to Array": {
      "main": [
        [
          {
            "node": "Save Client with Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Extract Image Metadata",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Image Metadata": {
      "main": [
        [
          {
            "node": "decrypt image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Process AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CONVO": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent1": {
      "main": [
        [
          {
            "node": "Process Image Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Image Response": {
      "main": [
        [
          {
            "node": "Send WhatsApp Reply1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send WhatsApp Reply1": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent Memory1": {
      "ai_memory": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Existing Client": {
      "main": [
        [
          {
            "node": "Merge Image Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Image Data": {
      "main": [
        [
          {
            "node": "MongoDB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "641b86b6-ddc2-4586-8dc0-16fc5dc4b99f",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "05debc04038961337b694414b80afd58c9192a325b8e07e72331d6b505d388ac"
  },
  "id": "9AyVRp0MXaQM4LHF",
  "tags": [
    {
      "createdAt": "2025-08-11T11:03:12.782Z",
      "updatedAt": "2025-08-11T11:03:12.782Z",
      "id": "fxnG4IaUnFjYhCf6",
      "name": "whatsapp-ai"
    },
    {
      "createdAt": "2025-08-11T11:03:12.819Z",
      "updatedAt": "2025-08-11T11:03:12.819Z",
      "id": "u6GyntPyho5GOGBq",
      "name": "wasender-api"
    }
  ]
}